{"entries":[{"timestamp":1735049047018,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"_only_v0"],[-1,"6"],[1,"5"],[0,"\",\n    \""]],"start1":39,"start2":39,"length1":17,"length2":17}]}]},{"timestamp":1735049047626,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"E_ROUTE\n"],[-1,"                \n"],[0,"        "]],"start1":23958,"start2":23958,"length1":33,"length2":16}]}]},{"timestamp":1735229796762,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"    "],[-1,"if DEBUG: serial.write_line(\"radio tx\")"],[0,"\n   "]],"start1":23978,"start2":23978,"length1":47,"length2":8}]}]},{"timestamp":1735229799239,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"DEBUG = "],[-1,"Tru"],[1,"Fals"],[0,"e\n\nUseHu"]],"start1":329,"start2":329,"length1":19,"length2":20},{"diffs":[[0,"UTE\n"],[-1,"                if DEBUG: serial.write_line(\"release route gototarget\")\n"],[0,"    "]],"start1":22459,"start2":22459,"length1":80,"length2":8},{"diffs":[[0,"e(\"r"],[-1,"elease route grabobject"],[1,"adio tx"],[0,"\")\n "]],"start1":24008,"start2":24008,"length1":31,"length2":15},{"diffs":[[0,"tr\n\n"],[-1,"latsprint = input.running_time()\n"],[1,"'''"],[0,"\ndef"]],"start1":36679,"start2":36679,"length1":41,"length2":11},{"diffs":[[0,"EBUG"],[-1,", latsprint"],[0,"\n   "]],"start1":36724,"start2":36724,"length1":19,"length2":8},{"diffs":[[0," DEBUG:\n        "],[-1,"#"],[0,"serial.write_val"]],"start1":36735,"start2":36735,"length1":33,"length2":32},{"diffs":[[0,"())\n"],[-1,"        t = input.running_time()\n        serial.write_value(\"t : \",t/1000)\n        serial.write_value(\"dt: \", (t-latsprint)/1000)\n        latsprint = t\n"],[0,"    "]],"start1":36804,"start2":36804,"length1":160,"length2":8},{"diffs":[[0,"ass\n"],[-1,"'''    \n"],[0,"loop"]],"start1":37832,"start2":37832,"length1":16,"length2":8},{"diffs":[[0,"bot)"],[-1,"\n            print_data()"],[0,"\n\n  "]],"start1":42828,"start2":42828,"length1":33,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"DEBUG = "],[-1,"tru"],[1,"fals"],[0,"e\nlet Us"]],"start1":376,"start2":376,"length1":19,"length2":20},{"diffs":[[0,"UTE\n"],[-1,"                if (DEBUG) {\n                    serial.writeLine(\"release route gototarget\")\n                }\n                \n"],[0,"    "]],"start1":26027,"start2":26027,"length1":137,"length2":8},{"diffs":[[0,"UTE\n"],[-1,"                if (DEBUG) {\n                    serial.writeLine(\"release route grabobject\")\n                }\n                \n"],[0,"    "]],"start1":27595,"start2":27595,"length1":137,"length2":8},{"diffs":[[0,"\n}\n\n"],[-1,"let latsprint = input.runningTime()\nfunction print_data() {\n    let t: number;\n    let _cmd: number;\n    let _chk: any;\n    let _str: string;\n    "],[1,"/** \ndef print_data():\n    global robot, DEBUG"],[0,"\n    if "],[-1,"("],[0,"DEBUG"],[-1,") {"],[1,":"],[0,"\n       "],[-1," //"],[0," ser"]],"start1":42570,"start2":42570,"length1":182,"length2":76},{"diffs":[[0,"    "],[-1,"t = input.runningTime()\n        serial.writeValue(\"t : \", t / 1000)\n        serial.writeValue(\"dt: \", (t - latsprint) / 1000)\n        latsprint = t\n        serial.writeL"],[1,"serial.write_l"],[0,"ine("]],"start1":42704,"start2":42704,"length1":177,"length2":22},{"diffs":[[0,"ine(\"speed \""],[-1," + "],[1,"+"],[0,"robot.speed)"]],"start1":42722,"start2":42722,"length1":27,"length2":25},{"diffs":[[0,"serial.write"],[-1,"L"],[1,"_l"],[0,"ine(\"yaw spe"]],"start1":42756,"start2":42756,"length1":25,"length2":26},{"diffs":[[0," speed \""],[-1," + "],[1,"+"],[0,"robot.ya"]],"start1":42778,"start2":42778,"length1":19,"length2":17},{"diffs":[[0,"serial.write"],[-1,"L"],[1,"_l"],[0,"ine(\"distanc"]],"start1":42812,"start2":42812,"length1":25,"length2":26},{"diffs":[[0," target\""],[-1," + "],[1,"+"],[0,"robot.di"]],"start1":42839,"start2":42839,"length1":19,"length2":17},{"diffs":[[0,"serial.write"],[-1,"V"],[1,"_v"],[0,"alue(\"state\""]],"start1":42882,"start2":42882,"length1":25,"length2":26},{"diffs":[[0,"serial.write"],[-1,"L"],[1,"_l"],[0,"ine(state_na"]],"start1":42931,"start2":42931,"length1":25,"length2":26},{"diffs":[[0,"rite"],[-1,"L"],[1,"_l"],[0,"ine("],[-1,"\"\" + "],[1,"str("],[0,"\"tar"]],"start1":42991,"start2":42991,"length1":18,"length2":18},{"diffs":[[0,"arget \" "],[-1,"+ (\"\" + "],[1,") + str("],[0,"robot.ta"]],"start1":43007,"start2":43007,"length1":24,"length2":24},{"diffs":[[0,"rget) + "],[-1,"(\"\" + "],[1,"str("],[0,"\"  \") + "]],"start1":43031,"start2":43031,"length1":22,"length2":20},{"diffs":[[0,"serial.write"],[-1,"V"],[1,"_v"],[0,"alue(\"distan"]],"start1":43088,"start2":43088,"length1":25,"length2":26},{"diffs":[[0,"al.write"],[-1,"V"],[1,"_v"],[0,"alue(\"sp"]],"start1":43157,"start2":43157,"length1":17,"length2":18},{"diffs":[[0,"\n        _str = "],[1,"("],[0,"leading_zeros(ro"]],"start1":43340,"start2":43340,"length1":32,"length2":33},{"diffs":[[0,".id,"],[-1," "],[0,"2) + "],[-1,"(\"\" + "],[1,"str("],[0,"_cmd) + "],[-1,"(\"\" + "],[1,"str("],[0,"robo"]],"start1":43376,"start2":43376,"length1":34,"length2":29},{"diffs":[[0,"r(robot.state) +"],[1,"\n                   "],[0," leading_zeros(r"]],"start1":43399,"start2":43399,"length1":32,"length2":52},{"diffs":[[0,"(robot.location,"],[-1," "],[0,"2) + leading_zer"]],"start1":43449,"start2":43449,"length1":33,"length2":32},{"diffs":[[0,"bot.destination,"],[-1," "],[0,"2)"],[1," "],[0," + leading_zeros"]],"start1":43486,"start2":43486,"length1":35,"length2":35},{"diffs":[[0,"os(robot.target,"],[-1," "],[0,"2) +"],[1,"\n                   "],[0," leading_zeros(r"]],"start1":43519,"start2":43519,"length1":37,"length2":56},{"diffs":[[0,"tance_to_target,"],[-1," "],[0,"3) + leading_zer"]],"start1":43583,"start2":43583,"length1":33,"length2":32},{"diffs":[[0,"robot.speed,"],[-1," "],[0,"3) + "],[-1,"(\"\" + "],[1,"str("],[0,"_chk) + \"\\r\\"]],"start1":43618,"start2":43618,"length1":36,"length2":33},{"diffs":[[0,"tr(_chk) + \""],[-1,"\\r\\n\""],[1,"\r\n\")"],[0,"\n        ser"]],"start1":43636,"start2":43636,"length1":29,"length2":28},{"diffs":[[0,"serial.write"],[-1,"L"],[1,"_l"],[0,"ine(_str)\n  "]],"start1":43661,"start2":43661,"length1":25,"length2":26},{"diffs":[[0,"rite"],[-1,"L"],[1,"_l"],[0,"ine("],[-1,"\"--\""],[1,"'--'"],[0,")\n    "],[-1,"}\n    \n    \n}\n\n/** "],[1,"pass\n"],[0,"loop"]],"start1":43701,"start2":43701,"length1":42,"length2":29},{"diffs":[[0,"nt_data)"],[1,"\n\n"],[0," */\n/** "]],"start1":43755,"start2":43755,"length1":16,"length2":18},{"diffs":[[0,"ot)\n"],[-1,"            print_data()\n"],[0,"    "]],"start1":49076,"start2":49076,"length1":33,"length2":8}]}]},{"timestamp":1735230301726,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"or us\")\n        "],[1,"#"],[0,"if DEBUG: serial"]],"start1":38954,"start2":38954,"length1":32,"length2":33},{"diffs":[[0,"TxPending = "],[-1,"Fals"],[1,"Tru"],[0,"e\n        Wa"]],"start1":40463,"start2":40463,"length1":28,"length2":27},{"diffs":[[0,"UG: "],[-1,"\n                if robot.cmd == CLAIM_DESTINATION: serial.write_line(\"radio tx claim destinatination\")\n                if robot.cmd == RELEASE_ROUTE: serial.write_line(\"radio tx release route"],[1,"serial.write_line(\"radio tx"],[0,"\")\n "]],"start1":42347,"start2":42347,"length1":200,"length2":35}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[1," //"],[0," if "],[-1,"("],[0,"DEBUG"],[-1,") {\n           "],[1,":"],[0," ser"]],"start1":45080,"start2":45080,"length1":33,"length2":21},{"diffs":[[0,"serial.write"],[-1,"L"],[1,"_l"],[0,"ine(\"rx:\" + "]],"start1":45098,"start2":45098,"length1":25,"length2":26},{"diffs":[[0,"String)\n"],[-1,"        }\n        \n"],[0,"        "]],"start1":45132,"start2":45132,"length1":35,"length2":16},{"diffs":[[0,"adioTxPending = "],[-1,"fals"],[1,"tru"],[0,"e\n        Waitin"]],"start1":46773,"start2":46773,"length1":36,"length2":35},{"diffs":[[0,"    "],[-1,"if (robot.cmd == CLAIM_DESTINATION) {\n                    serial.writeLine(\"radio tx claim destinatination\")\n                }\n                \n                if (robot.cmd == RELEASE_ROUTE) {\n                    serial.writeLine(\"radio tx release route\")\n                }\n                "],[1,"serial.writeLine(\"radio tx\")"],[0,"\n   "]],"start1":48635,"start2":48635,"length1":299,"length2":36}]}]},{"timestamp":1735230788148,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"vel <= 0"],[-1,"+"],[0,":\n      "]],"start1":22300,"start2":22300,"length1":17,"length2":16}]}]},{"timestamp":1735231540700,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"el <= 0+"],[-1,"5"],[0,":\n      "]],"start1":22301,"start2":22301,"length1":17,"length2":16}]}]},{"timestamp":1735231540949,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"    "],[-1,"_proceed = False\n            if UseFleetmanager:"],[1,"if UseFleetmanager:\n                _proceed = False"],[0,"\n   "]],"start1":22364,"start2":22364,"length1":56,"length2":60}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"vel <= 0"],[-1," + 5"],[0,") {\n    "]],"start1":25861,"start2":25861,"length1":20,"length2":16},{"diffs":[[0,"    "],[-1,"_proceed = false\n            if (UseFleetmanager) {"],[1,"if (UseFleetmanager) {\n                _proceed = false"],[0,"\n   "]],"start1":25927,"start2":25927,"length1":59,"length2":63}]}]},{"timestamp":1735231902640,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"t\")\n"],[-1,"                if DEBUG: serial.write_line(\"reply: \" + str(_robot.reply))\n"],[0,"    "]],"start1":22528,"start2":22528,"length1":83,"length2":8},{"diffs":[[0,"        "],[-1,"el"],[0,"if Waiti"]],"start1":42867,"start2":42867,"length1":18,"length2":16},{"diffs":[[0,"ly and ("],[1,"RadioTxTime - "],[0,"input.ru"]],"start1":42891,"start2":42891,"length1":16,"length2":30},{"diffs":[[0,"me()"],[-1," - RadioTxTime"],[0,") > "]],"start1":42929,"start2":42929,"length1":22,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"   \n"],[-1,"                if (DEBUG) {\n                    serial.writeLine(\"reply: \" + (\"\" + _robot.reply))\n                }\n                \n"],[0,"    "]],"start1":26155,"start2":26155,"length1":142,"length2":8},{"diffs":[[0,"ue\n        }"],[-1," else"],[1,"\n        \n        //  start waiting for reply\n       "],[0," if (Waiting"]],"start1":49329,"start2":49329,"length1":29,"length2":77},{"diffs":[[0,"Reply &&"],[1," RadioTxTime -"],[0," input.r"]],"start1":49409,"start2":49409,"length1":16,"length2":30},{"diffs":[[0,"e() "],[-1,"- RadioTxTime > 1000) {\n            //  start waiting for reply"],[1,"> 1000) {"],[0,"\n   "]],"start1":49448,"start2":49448,"length1":71,"length2":17}]}]},{"timestamp":1735232435891,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"ss\n\n"],[-1,"        if DEBUG: serial.write_line(\"reply: \" + str(robot.reply))\n"],[0,"    "]],"start1":40518,"start2":40518,"length1":74,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"   \n"],[-1,"        if (DEBUG) {\n            serial.writeLine(\"reply: \" + (\"\" + robot.reply))\n        }\n        \n"],[0,"    "]],"start1":46924,"start2":46924,"length1":109,"length2":8}]}]},{"timestamp":1735232817100,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"er:\n"],[-1,"                _robot.route_reported = True\n                pass # do not report release position\n                '''\n"],[0,"    "]],"start1":21183,"start2":21183,"length1":127,"length2":8},{"diffs":[[0,"ass\n"],[-1,"                '''\n"],[0,"    "]],"start1":21448,"start2":21448,"length1":28,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") {\n"],[-1,"                _robot.route_reported = true\n                \n                //  do not report release position\n                /** \n"],[0,"    "]],"start1":24505,"start2":24505,"length1":142,"length2":8},{"diffs":[[0,"     if "],[1,"("],[0,"_robot.r"]],"start1":24566,"start2":24566,"length1":16,"length2":17},{"diffs":[[0,"y == ACK"],[-1,":"],[1,") {"],[0,"\n       "]],"start1":24586,"start2":24586,"length1":17,"length2":19},{"diffs":[[0,"eply = 0"],[1,"\n                    //"],[0," "],[-1,"#"],[0," reset f"]],"start1":24626,"start2":24626,"length1":18,"length2":40},{"diffs":[[0,"orted = "],[-1,"T"],[1,"t"],[0,"rue\n    "]],"start1":24718,"start2":24718,"length1":17,"length2":17},{"diffs":[[0,"            "],[-1,"pass"],[1,"}"],[0,"\n           "]],"start1":24782,"start2":24782,"length1":28,"length2":25},{"diffs":[[0,"          \n "],[-1,"*/"],[1,"               "],[0,"\n           "]],"start1":24802,"start2":24802,"length1":26,"length2":39}]}]}],"snapshots":[{"timestamp":1735049047017,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables></xml>","main.ts":"","README.md":"\n> Open this page at [https://artandtechvof.github.io/mpps_demonstrator_python_only_v02/](https://artandtechvof.github.io/mpps_demonstrator_python_only_v02/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/artandtechvof/mpps_demonstrator_python_only_v02** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/artandtechvof/mpps_demonstrator_python_only_v02** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n\n\n\n> Open this page at [https://artandtechvof.github.io/mpps_demonstrator_python_only_v05/](https://artandtechvof.github.io/mpps_demonstrator_python_only_v05/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/artandtechvof/mpps_demonstrator_python_only_v05** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/artandtechvof/mpps_demonstrator_python_only_v05** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","main.py":"CollisionDetection = False\nRandomDestination = True # random object or object based on own ID\nHIL_Simulation = True    # run code on \nFirstClaimDestination = True # True: wait for destination area te be cleared.\n                             # False: turn towards destination even if it is occupied\nUseFleetmanager = True\nID = 1\n\nDEBUG = False\n\nUseHusky = False\nDisplayDelay = 200\n\ndef showText(txt):\n    #if not HIL_Simulation:\n    if UseHusky:\n        txt = str(ID) + ' ' + txt\n        huskylens.clear_osd()\n        huskylens.write_osd(txt, 30, 30)\n        if HIL_Simulation: basic.pause(DisplayDelay)\n\n\n######################################\nserial.redirect_to_usb()\nserial.write_string(\"I am alive\")\nif not HIL_Simulation or UseHusky:\n    huskylens.init_i2c()\n    huskylens.init_mode(protocolAlgorithm.ALGORITHM_TAG_RECOGNITION)\n    showText(\"BOOTING\")\nbasic.pause(1000)\n######################################\n# number of robots\nnumrobots = 1\n# number of 'plastic' object types\nnumobjects = 4 # should be an even number for now\nnumtargets = numobjects\n# buffer zones for wating robots\n# 1 robot = 1 waiting\n# 2 robot = 1 waiting, 1 on storage location\n# 3 robot = 3 waiting, 1 left, 1 right 1 central\n# 4 robot = 5 waiting, 2 left, 2 right, 1 central\n# 5 robot = 7 waiting, 3 left, 3 right, 1 central\n# 6 robot = 9 waiting, 4 left, 4 right, 1 central\n# 7 robot = 11 waiting, 5 left, 5 right, 1 central\n# 8 robots = 13 waiting, 6 left, 6 right, 1 central\nif numrobots == 1:\n    numwaitingareas = 5 # adjust to demo\nelse:\n    numwaitingareas = max(3,(numrobots-1)*2 -1) # 1 central waiting area offset to the front\nnumstorage = 1 # try increasing this in future scenarios, attack waste-pile from multiple locations\n# total number of locations where robots can go\nnumlocations = numwaitingareas + numstorage + numtargets + numobjects\n\n\n# constants\nIDLE = 0\nDRIVEBACKWARD = 1\nFINDTARGET = 2\nGOTOTARGET = 3\nFINDOBJECT = 4\nGRABOBJECT = 5\n\nLOCATION_t = 0 # robot is looking for location\nOBJECT_t = 1   # robot is looking for object\n\nOPENED = 1\nCLOSED = 0\n\nAHEAD = 0\nLEFT  = 1\nRIGHT = 2\n\nMAXSPEED = 25\nMINSPEED = 15\nMINYAWSPEED = 8\nMAXYAWSPEED = 14\nBACKUPSPEED = -20\nBACKUPDISTANCE = 20\n\nOBJECT_THRESHOLD = 0 # minimum distance to object, before closing grippers\n\nstate_names = ['IDLE', 'DRIVEBACKWARD', 'FINDTARGET', 'GOTOTARGET', 'FINDOBJECT', 'GRABOBJECT']\ndirection_names = ['AHEAD', 'LEFT', 'RIGHT']\ncmd_names = ['STATUS_UPDATE','CLAIM_DESTINATION','RELEASE_POSITION','RELEASE_ROUTE','ROBOT_START','ROBOT_STOP']\nrply_names = ['NOK','OK','ACK']\n\n# commands\nSTATUS_UPDATE = 0\nCLAIM_DESTINATION = 1\nRELEASE_POSITION = 2\nRELEASE_ROUTE = 3\nROBOT_START = 4\nROBOT_STOP = 5\nNOK = 0\nOK = 1\nACK = 2\n\n#initialize variables related to huskylens\nt_start = 0\nt_last = 0\ndt_AI = 0\ninview = 0\nx = 0\ny = 0\nw = 0\nh = 0\nnewdata = False\ninview_count = 0\nRadioTxPending = False\n\ntagID = 1\n# tagIDs = [1 tm 6]\ntagSizes = [0,  85, 90, 90, 90, 85,  88,  88, 88, 88, 88,  55, 55, 55, 55] # 5x waiting, 1 central, 4 targets, 4 objects\n\ntagSize = tagSizes[tagID]\n\nzeroes = [0]\nwhile i < len(tagSizes):\n    zeroes.append(0)\n    i += 1\ntagsInView = zeroes\n#start_searching = 0\n\n\n#---------------------------------------------------------------------------------------------------------\n# helper function to open and close grippers, will be different on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef open_gripper():\n    opengripper = True\n    maqueen.servo_run(maqueen.Servos.S1, 85)\n    return opengripper\n\n\ndef close_gripper():\n    closegripper = True\n    maqueen.servo_run(maqueen.Servos.S1, 105)\n    return closegripper\n\ndef actuate_motors():\n    if HIL_Simulation: return True\n\n    left_speed = (robot.speed + robot.yaw_speed)\n    right_speed = (robot.speed + -robot.yaw_speed)\n    #serial.write_line(str(left_speed)+\" left speed\")\n    #serial.write_line(str(right_speed)+\" right speed\")\n    # set speed for motors here\n    if left_speed >=0:\n        maqueen.motor_run(maqueen.Motors.M1, maqueen.Dir.CW, left_speed)\n    else:\n        maqueen.motor_run(maqueen.Motors.M1, maqueen.Dir.CCW, -left_speed)\n    if right_speed >=0:\n       maqueen.motor_run(maqueen.Motors.M2, maqueen.Dir.CW, right_speed)\n    else:\n        maqueen.motor_run(maqueen.Motors.M2, maqueen.Dir.CCW, -right_speed)\n\n    return True\n\ndef get_time():\n    return input.running_time()\n\n#---------------------------------------------------------------------------------------------------------\n# base class of robot, can also be used on micro:Maqueen robot.\n# Robot() class, should be same for offline Simulation and actual physical demo robot\n#---------------------------------------------------------------------------------------------------------\nclass Robot:\n    def __init__(self, loc=1, dst=1, _id=1):\n        # who are we\n        self.id = _id\n        # ego location and destination nr\n        self.location = loc\n        self.destination = dst\n        self.target = dst\n        self.targettype = LOCATION_t\n        self.objecttype = None\n        # states\n        self.state = IDLE\n        self.gripper = CLOSED\n        self.speed = 0\n        self.yaw_speed = 0\n        # params\n        self.active = False\n        self.run_enable = False\n        self.steering_only = False # allowed to change heading but not driving\n        self.target_direction = AHEAD\n        self.target_inview = False  # target is in view of camera\n        self.target_locked = False # target is straight ahead\n        self.backup_distance = 0\n        self.distance_to_target = 0\n        self.backup_starttime = 0\n        self.looking_for_object = 0\n        self.route_length = 0\n        self.route_reported = False\n        self.obstacle_detected = False\n        self.cmd = 0\n        self.reply = 0\n\n    def gripper_open(self):\n        if open_gripper():\n            self.gripper = OPENED\n        pass\n\n    def gripper_close(self):\n        if close_gripper():\n            self.gripper = CLOSED\n        pass\n\n#---------------------------------------------------------------------------------------------------------\n# pre allocate robot instance as global\n#---------------------------------------------------------------------------------------------------------\nrobot = Robot( loc=ID, dst=ID, _id=ID)\n\n\n#---------------------------------------------------------------------------------------------------------\n# this function will be based on camera on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef calc_heading(_robot=Robot()):\n\n    #angle error in pixels\n    # x = position of tag in camera view, 320 wide, 160 is center\n    if HIL_Simulation:\n        basic.pause(100)\n        return 0\n        \n    angle_err = 160-x\n    \n    return angle_err\n\n\n#---------------------------------------------------------------------------------------------------------\n# this function will be based on camera on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef calc_distance(_robot=Robot()):\n    '''\n    if not _robot.state == DRIVEBACKWARD:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.dest[0]))**2 + ((_robot.position[1] - _robot.dest[1]))**2)\n    else:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.startposition[0]))**2 + ((_robot.position[1] - _robot.startposition[1]))**2)\n    '''\n    tagSize = tagSizes[_robot.target]\n    tagID = _robot.target\n    \n    if HIL_Simulation:\n        if not _robot.state == DRIVEBACKWARD:\n            distance_measured = _robot.distance_to_target - _robot.speed # drive towards target\n        else:\n            distance_measured = _robot.distance_to_target + abs(_robot.speed) # drive away from target\n    else :\n        distance_measured = tagSize - h  # height of tag - height of tag measured\n        #serial.write_line('h='+h+'tagsize:'+tagSize) # soort timeout invoeren\n    \n    distance_measured = max(distance_measured,0) # distance cannot be negative\n\n    return distance_measured\n    \n\n#---------------------------------------------------------------------------------------------------------\n# look for target and aim robot towards it, different in offline Simulation vs actual robot\n#---------------------------------------------------------------------------------------------------------\ndef find_target(_robot=Robot()):\n    # We are driving towards a location\n    if _robot.targettype == LOCATION_t:\n        _robot.target = _robot.destination\n    # We are looking for and driving to an object\n    if _robot.targettype == OBJECT_t:\n        # start looking for the object\n        _robot.target = obj[_robot.objecttype] # obj location nr will become new target\n\n    _robot.steering_only = True\n    # set preffered turning direction?\n    # actuate drive and steering\n\n    _dist = move_robot(_robot)\n    return _dist\n\n#---------------------------------------------------------------------------------------------------------\n#function to search target\n#---------------------------------------------------------------------------------------------------------\ndef pulse(_dir=LEFT,_robot=Robot()):\n    #pulsing behaviour\n    pulse_duration = 700  # Duration of one complete pulse cycle\n    active_ratio = 0.2  # Ratio of time the robot is actively turning within a pulse\n    base_speed = 15\n    speed_multiplier = 1.5\n\n    if robot.state == FINDOBJECT:\n        speed_multiplier = 1.5\n        if robot.looking_for_object == 0:\n            _robot.looking_for_object = input.running_time()\n        else:\n            time_looking = input.running_time() - _robot.looking_for_object\n            if time_looking < 2000:\n                 _dir = LEFT\n            else: _dir = RIGHT\n\n\n\n\n    #if start_searching == 0: # als\n    #    start_searching = input.running_time()\n    \n    #calculate searching time\n    #searching_time = input.running_time() - start_searching\n    # Calculate the phase of the pulse (0 to 1)\n    pulse_phase = (input.running_time() % pulse_duration) / pulse_duration\n\n    #calculate if we are in the active part of the pulse\n    is_active_pulse = pulse_phase < active_ratio\n\n    if is_active_pulse:\n        # During active pulse: turn with increased speed\n        turn_speed = base_speed * speed_multiplier\n    else:\n        # During inactive pulse: stand still\n        turn_speed = base_speed\n\n    if _dir == LEFT: turn_speed = -turn_speed\n\n    return turn_speed\n\n\n    #if payload:\n    #    speed_left *= 1.15\n    #    speed_right *= 1.15\n\n#---------------------------------------------------------------------------------------------------------\n# actual motion control, aim for target, with or without speed\n#---------------------------------------------------------------------------------------------------------\ndef move_robot(_robot=Robot()):\n\n    #check if robot is allowed to move\n    dist_err = 999 # default distance error\n    if not _robot.run_enable:\n            _robot.speed = 0\n            _robot.yaw_speed = 0\n\n    #check if target is in sight\n    if (_robot.target in tagsInView) or HIL_Simulation:\n            _robot.target_inview = True\n                                              \n                                                      \n\n    else:\n        # add timeout before target is no longer in view???\n        _robot.target_inview = False\n        _robot.target_locked = False\n\n    #if target is not in view turn around to look for target, use pulsed turning to speed up process\n    if not _robot.target_inview:\n        _robot.speed = 0\n        _robot.yaw_speed = pulse(_robot.target_direction,_robot)\n    # if target is in view\n    else:\n        # heading / steering control\n        angle_err = calc_heading(_robot) # how many pixels are we off centre\n        dist_err = calc_distance(_robot) # how many pixels are we away from target\n        _robot.distance_to_target = dist_err # store on instance of robot, for logistical and rouet handling\n\n        # heading control, simple P-control\n        Kp = 1.0\n        _robot.yaw_speed = -angle_err * Kp # simple P-control of heading angle\n        if _robot.target_locked:\n            _robot.yaw_speed = max(-MAXYAWSPEED, min(_robot.yaw_speed, MAXYAWSPEED))\n        else:\n            _robot.yaw_speed = max(-MAXYAWSPEED, min(_robot.yaw_speed, MAXYAWSPEED))\n\n        # speed control, start driving when target is almost straight ahead of robot\n        if abs(angle_err) < 10:\n            _robot.yaw_speed = 0\n            _robot.target_locked = True\n            # speed control, simple P-control\n            Kp = 2.0\n            _robot.speed = min(dist_err * Kp, MAXSPEED)\n            # drive slow when approaching an object\n            if _robot.state == GRABOBJECT: _robot.speed = min(MINSPEED, _robot.speed * Kp)\n            \n        else:\n            _robot.target_locked = False\n\n        # steering only when aiming for target\n        if _robot.steering_only:\n            _robot.speed = 0\n\n        # if obstacle detected stop robot\n        if CollisionDetection and collision_detected(_robot):\n            _robot.speed = 0\n            _robot.yaw_speed = 0\n\n        # adjust turning speed depening on driving or turning when standing still\n        if _robot.speed > 0 :\n            # while driving reduce maximum turning speed, for smoother driving\n            _robot.yaw_speed = max(-MINYAWSPEED/4, min(_robot.yaw_speed, MINYAWSPEED/4))\n\n        else:\n            # turn while standing still, use minimum turning speed\n            if  _robot.yaw_speed > 0:\n                if _robot.yaw_speed < MAXYAWSPEED: _robot.yaw_speed = MAXYAWSPEED\n            if  _robot.yaw_speed < 0:\n                if _robot.yaw_speed > -MAXYAWSPEED: _robot.yaw_speed = -MAXYAWSPEED\n\n    actuate_motors()\n    return dist_err\n\n\n#---------------------------------------------------------------------------------------------------------\n# actively stop robot\n#---------------------------------------------------------------------------------------------------------\ndef stop_robot(_robot=Robot()):\n    _robot.speed = 0\n    _robot.yaw_speed = 0\n    actuate_motors()\n\n#---------------------------------------------------------------------------------------------------------\n# drive backward to clear storage or target areas\n#---------------------------------------------------------------------------------------------------------\ndef reverse_robot(_robot=Robot()):\n    dist_err = calc_distance(_robot)\n    # drive straight backward, without steering\n    _robot.yaw_speed = 0\n    # have we driven far enough backward? distance is trigger, could also be timed reverse driving\n    if (input.running_time() - _robot.backup_starttime) < 750: # 0.75 seconds\n        _robot.looking_for_object = 0\n    #if dist_err < _robot.backup_distance:\n        _robot.speed = BACKUPSPEED\n        _finished = False\n    else:\n        _finished = True\n        _robot.speed = 0\n    actuate_motors()\n    return _finished\n\n\n#---------------------------------------------------------------------------------------------------------\n# run robot main code (similar to real-time implementation)\n#---------------------------------------------------------------------------------------------------------\ndef do_robot(_robot=Robot()):\n    # statemachine\n    if _robot.state == IDLE:\n        _robot.run_enable = False\n        _robot.speed = 0\n        _robot.yaw_speed = 0\n        _robot.cmd = STATUS_UPDATE\n        stop_robot(_robot)\n        if _robot.active:\n            # we are allowed to drive\n            _robot.run_enable = True\n            # request next destination, if we cary an object we are going to an output stream area\n            result = next_destination( _robot.destination, _robot.objecttype)\n            _robot.destination = result[0]\n            _robot.target_direction = result[1]\n            _robot.target = _robot.destination\n            # if we are in the waiting area, we do not need to back up, otherwise, backup before driving\n            if HIL_Simulation:\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n            # maybe  try to claim the location here. With QR code another robot might be in the way of seeing the QR code\n            # when the robot has reased its starting position (claim released) the QR code should be visible\n            if _robot.location in waitingarea:\n                _robot.backup_distance = 0\n                _robot.state = FINDTARGET  # directly start aiming for next destination\n                #serial.write_line(\"state find target\")\n                showText(\"FINDTARGET: \" + str(_robot.target) + ' ' + direction_names[_robot.target_direction])\n                # for HIL_Simulation only\n                if HIL_Simulation:\n                    _robot.distance_to_target = 90\n                    _robot.route_length = _robot.distance_to_target\n\n            else:\n                # backup distance\n                _robot.backup_distance = BACKUPDISTANCE\n                #serial.write_line(\"state drive backwards\")\n                showText(\"DRIVEBACKWARD\")\n                _robot.state = DRIVEBACKWARD  # drive backwards first\n                _robot.backup_starttime = get_time() # input.running_time()\n                # if wa are at target area, weh open gripper and drive backward to leave object there\n                if _robot.location in target[1:numtargets+1]:\n                    _robot.gripper_open()\n                    _robot.objecttype = None # we leave the object here\n                    pass\n                #elif _robot.location in storagearea:\n                # randomly assign new object to location where last object was taken from\n                #    nxt_object = randint(1, numobjects+1)\n                #    waste_object[_robot.objecttype].color = colorlist[nxt_object]  # we leave the object here\n                #    waste_object[_robot.objecttype].objecttype = nxt_object\n                #    pass\n                else:\n                    # all other areas we drive backward with grippers closed\n                    _robot.gripper_close()\n                    pass\n                # for HIL_Simulation only\n                if HIL_Simulation: _robot.distance_to_target = 0\n        pass\n    elif _robot.state == DRIVEBACKWARD:\n        # drive backwards\n        if reverse_robot(_robot):\n            _robot.state = FINDTARGET\n            showText(\"FINDTARGET: \" + str(_robot.target) + ' ' + direction_names[_robot.target_direction])\n            _robot.gripper_close()\n            # for HIL_Simulation only\n            if HIL_Simulation:\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n        pass\n    elif _robot.state == FINDTARGET:\n        # find target by rotating robot, but do not drive\n        _proceed = False\n        if FirstClaimDestination:\n             if UseFleetmanager:\n                 _robot.cmd = CLAIM_DESTINATION\n                 if _robot.reply == OK:\n                     _robot.reply = 0 # reset for next command\n                     _proceed = True\n                     _robot.cmd = STATUS_UPDATE\n                 pass\n             else:\n                if claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                    _proceed = True\n        else:\n            _proceed = True\n\n        if _proceed:\n            _robot.targettype = LOCATION_t\n            _dist_to_travel = find_target(_robot)\n            # when we have found the target, we are going to drive towards it\n            if _robot.target_locked:\n                # we have found the target, re-check if it is clear to drive there\n                #if CollisionDetection or claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                if not FirstClaimDestination:\n                    _proceed = False\n                    if CollisionDetection:\n                        _proceed = True\n                    elif UseFleetmanager:\n                        _robot.cmd = CLAIM_DESTINATION\n                        if _robot.reply == OK:\n                            _robot.reply = 0 # reset for next command\n                            _proceed = True\n                            _robot.cmd = STATUS_UPDATE\n                        pass\n                    elif claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                            _proceed = True\n                if _proceed:\n                    showText(\"GOTOTARGET: \" + str(_robot.target))\n                    _robot.state = GOTOTARGET\n                    _robot.route_reported = False\n                    _robot.route_length = _dist_to_travel\n                    _robot.cmd = STATUS_UPDATE\n        pass\n    elif _robot.state == GOTOTARGET:\n        # make sure we keep claim on target area\n        _robot.steering_only = False\n        _dist_to_travel = move_robot(_robot)\n        _proceed = False\n        _robot.cmd = STATUS_UPDATE\n        # report route haflway, only onetime reporting\n        if _dist_to_travel < _robot.route_length/2 and not _robot.route_reported:\n            if UseFleetmanager:\n                _robot.cmd = RELEASE_POSITION\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _robot.route_reported = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_position(_robot.location)\n                _robot.route_reported = True\n        _robot.distance_to_target = _dist_to_travel\n        # if we approach storage, open gripper before reaching destination\n        if _robot.destination in storagearea:\n            if _dist_to_travel == 0:\n                _robot.state = FINDOBJECT\n                # assign an object to look for\n                if RandomDestination:\n                    _robot.objecttype = randint(1, numobjects) # a random object is assigned to robot\n                else:\n                    _robot.objecttype = _robot.id  # robot ID determines object types to be retrieved\n                # switch state and start looking for object\n                showText(\"FINDOBJECT: \" + str(_robot.objecttype))\n                pass\n        elif _dist_to_travel <= 0:\n            # target reached, release route\n            if UseFleetmanager:\n                _proceed = False\n                _robot.cmd = RELEASE_ROUTE\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _proceed = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_route(_robot.location, _robot.destination)\n                _proceed = True\n            # update position\n            if _proceed:\n                _robot.location = _robot.destination\n                _robot.state = IDLE\n                _robot.cmd = STATUS_UPDATE\n                showText(\"IDLE\")\n        pass\n    elif _robot.state == FINDOBJECT:\n        # Finding object could be done by sweeping left and reight until object is found\n        _robot.steering_only = True\n        # if we approcah storage, open gripper before reaching destination\n        _robot.targettype = OBJECT_t\n        find_target(_robot)\n        if _robot.target_locked:\n            _robot.steering_only = False\n                                                     \n            _robot.gripper_open()\n            _robot.state = GRABOBJECT\n            showText(\"GRABOBJECT: \" + str(_robot.objecttype))\n            \n    elif _robot.state == GRABOBJECT:\n        _dist_to_travel = move_robot(_robot)\n        if _dist_to_travel <= OBJECT_THRESHOLD+5:\n                                                      \n            _robot.gripper_close()\n            _proceed = False\n            # target reached, release route\n            if UseFleetmanager:\n                _robot.cmd = RELEASE_ROUTE\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _proceed = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_route(_robot.location, _robot.destination)\n                _proceed = True\n            # update position\n            if _proceed:\n                _robot.location = _robot.destination\n                # switch to idle to start next route\n                _robot.state = IDLE\n                showText(\"IDLE\")\n        pass\n\n\n#---------------------------------------------------------------------------------------------------------\n# collision detection, can be based on camera or sensor on robot\n#---------------------------------------------------------------------------------------------------------\ndef collision_detected(_robot=Robot()):\n    #\n    # Needs implementing on robot\n    #\n    _robot.obstacle_detected = False\n    obstacle_detected = False\n    return obstacle_detected\n\n\n\n#---------------------------------------------------------------------------------------------------------\n#\n#  ROUTE HANDLING BELOW\n#\n#---------------------------------------------------------------------------------------------------------\n\n#---------------------------------------------------------------------------------------------------------\n# locations id's\n#---------------------------------------------------------------------------------------------------------\n\n# ids of waiting areas\nwaitingarea = [0]\nfor i in range(numwaitingareas):\n    waitingarea.append(i+1)\n# ids of storage areas\nstoragearea = [0]\nfor i in range(numwaitingareas, numwaitingareas+numstorage):\n    storagearea.append(i+1)\n# ids of target areas\ntarget = [0]\nfor i in range(numwaitingareas+numstorage, numwaitingareas+numstorage+numtargets):\n    target.append(i+1)\n# ids of objects\nobj = [0]\nfor i in range(numwaitingareas+numstorage+numtargets, numwaitingareas+numstorage+numtargets+numobjects):\n    obj.append(i+1)\n\n#occupation list of all locations\n#occupying = [0]  * (numlocations +1) -> does not work in Makecode\n# for compatibility reasons wit MakeCode on robot, do it like this\noccupying = [0]\nfor i in range(numlocations +1):\n    occupying.append(0)\n\nlocationnames = ['None']\nfor i in range(1,numwaitingareas+1):\n    locationnames.append(str('waitingarea ') + str(i))\nlocationnames.append(str('storage 1'))\nfor i in range(1,numobjects+1):\n    locationnames.append(str('targetarea ') + str(i))\nfor i in range(numobjects+1):\n    locationnames.append(str('object ') + str(i+1))\n\n#---------------------------------------------------------------------------------------------------------\n# instances of routes, using location id's\n#---------------------------------------------------------------------------------------------------------\nroutes = [(0,0)]\nfor i in range(50):\n    routes.append((0,0))\n\n# route automatic define from location, to location, use location numbers instead of coordinates for easier update\nfor i in range(numwaitingareas):\n    routes[i] = (waitingarea[1+i], storagearea[1])\noffset = numwaitingareas\nfor i in range(numobjects):\n    routes[i+offset] = (storagearea[1], target[1+i])\noffset += i+1\nfor i in range(numobjects):\n    if i < numobjects/2:\n        routes[i+offset] = (target[i+1], waitingarea[1])\n    else:\n        routes[i + offset] = (target[i+1], waitingarea[len(waitingarea)-1]) # waitingarea[-1] is not compatibel with Makecode\noffset += i+1\nidx = 0\nfor i in range(1, numwaitingareas):\n    if i < numwaitingareas/2:\n        routes[offset+i-1] = (waitingarea[i], waitingarea[i+1]) # shift from left to middle\n        idx = i\n    else:\n        routes[offset+i-1] = (waitingarea[len(waitingarea)-1]-i+idx+1, waitingarea[len(waitingarea)-1]-i+idx) # shift from right to middle\n\n\n# potentially crossing route combinations for additional clearance check\n# crossing routes:\n# - all routes from storage to targets in combination with all targets to waitingarea\n# - combination have to be all on left side or right side, right and left never cross (for now)\ncrossing_routes_ids = [((0,0),(0,0))]\ncrossing_routes = [(0,0)]\nfor i in range(len(routes)):\n    if routes[i][0] == storagearea[1]:\n        for j in range(len(routes)):\n            if routes[j][1] == waitingarea[1]:\n                if routes[j][0]<routes[i][1]:\n                    if routes[i][1] in target[1:int(numtargets/2)+1]:\n                        crossing_routes_ids.append((routes[i],routes[j]))\n                        crossing_routes.append((i, j))\n            if routes[j][1] == waitingarea[len(waitingarea)-1]:\n                if routes[j][0] < routes[i][1]:\n                    if routes[i][1] in target[int(numtargets/2)+1:numtargets+1]:\n                        crossing_routes_ids.append((routes[i], routes[j]))\n                        crossing_routes.append((i, j))\n\nactive_routes = [False]\nfor i in range(len(routes) +1):\n    active_routes.append(False)\ncrossed_routes = [False]\nfor i in range(len(routes) +1):\n    crossed_routes.append(False)\n\n\n#---------------------------------------------------------------------------------------------------------\n# check what next destination will be, this is the route scheduler, might be local or remote implemented\n#---------------------------------------------------------------------------------------------------------\ndef next_destination(_location, objecttype = None):\n    nxt_dest = _location # if there is no new location found, return current position as next destination\n    target_dir = AHEAD\n    # if we pick up an object, object nr tels us where to go\n    if (_location in storagearea) and (objecttype is not None):\n        # were need the collected object go to?\n        nxt_dest = target[objecttype]\n        # is target location left or rigth of us?\n        if nxt_dest in target[1:int(numtargets/2)+1]:\n            target_dir = LEFT\n        elif nxt_dest in target[int(numtargets/2)+1:numtargets+1]:\n            target_dir = RIGHT\n    # if we come from a target to the left, goto left most waiting area\n    elif _location in target[1:int(numtargets/2)+1]:\n        nxt_dest = waitingarea[1]\n        target_dir = LEFT\n    # if we come from a taget to the right, goto right most waiting area\n    elif _location in target[int(numtargets/2)+1:numtargets+1]:\n        nxt_dest = waitingarea[len(waitingarea)-1]\n        target_dir = RIGHT\n    # if we are in the waiting area, move toward the center wating area, before going back to the storage\n    elif _location in waitingarea:\n        # from waiting to storeage, unless we have to shift in the waiting area\n        nxt_dest = storagearea[1]\n        target_dir = LEFT\n        for i in range(1,int(numwaitingareas/2)+1):\n            # from left to middle\n            if _location == waitingarea[i]:\n                nxt_dest = waitingarea[i+1]\n                target_dir = LEFT\n            # from right to middle\n            if _location == waitingarea[len(waitingarea)-1]-i+1:\n                nxt_dest = waitingarea[len(waitingarea)-1]-i\n                target_dir = RIGHT\n    return nxt_dest, target_dir\n\n\n#---------------------------------------------------------------------------------------------------------\n# try to claim destination, if succesfull, returns True and own ID, if unsuccesfull returns ID that occupies the destination\n#---------------------------------------------------------------------------------------------------------\ndef claim_destination(_loc=0, _dest=0, _id=0):\n    claimed = 0\n    occupied = occupying[_dest]\n    if occupied == 0 and _id > 0:\n        occupying[_dest] = _id\n        claimed_id = _id\n        claimed = 1\n    else:\n        claimed_id = occupying[_dest]\n    if claimed_id == _id > 0:\n        if check_routes(_loc, _dest, _id):\n            occupying[_dest] = _id\n            #release_position(_loc) # this assumes that you start driving imediatly after claim of location\n        else:\n            claimed_id = 0\n    return claimed, claimed_id\n\n\n#---------------------------------------------------------------------------------------------------------\n# check if a destination is occupied, return ID that occupies destination\n#---------------------------------------------------------------------------------------------------------\ndef check_occupied(_dst):\n    claimed, occupied = claim_destination(_dest=_dst)\n    return occupied\n\n\n#---------------------------------------------------------------------------------------------------------\n# release location when you have left it\n#---------------------------------------------------------------------------------------------------------\ndef release_position(_location):\n    occupying[_location] = 0\n    return True\n\n\n#---------------------------------------------------------------------------------------------------------\n# release a route when we finished driving it\n#---------------------------------------------------------------------------------------------------------\ndef release_route(_loc,_dest):\n    _route = (_loc,_dest)\n    #if _route in [r for r in routes]: # not compatible with makecode\n    _found = False\n    for i in range(len(routes)):\n        if _route == routes[i]: _found = True\n    if _found:\n        # get route nr\n        _route_nr = routes.index(_route)\n        active_routes[_route_nr] = False\n    # check if route is actually released before returning -> need for remote implementation\n    while active_routes[_route_nr]:\n        # keep on trying to release the route\n        pass\n\n\n\n#---------------------------------------------------------------------------------------------------------\n# check if routes are crossing, claim route if crossing path is free\n#---------------------------------------------------------------------------------------------------------\ndef check_routes(_loc, _dest, _id):\n    if CollisionDetection: return True\n    proceed = True\n    # check start location of route\n    # is route valid and in route list]\n    _route = (_loc,_dest)\n    #if _route in [r for r in routes]: # not compatible with makecode\n    _found = False\n    for i in range(len(routes)):\n        if _route == routes[i] and routes[i] != (0, 0):\n            _found = True\n    if _found:\n        # get route nr\n        _route_nr = routes.index(_route)\n        #_r1 = _route_nr in [r[0] for r in crossing_routes]  # not compatible with makecode\n        #_r2 = _route_nr in [r[1] for r in crossing_routes] # not compatible with makecode\n        _r1 = False\n        _r2 = False\n        for i in range(1,len(crossing_routes)):\n            if _route_nr == crossing_routes[i][0]: _r1 = True\n            if _route_nr == crossing_routes[i][1]: _r2 = True\n        if _r1 or _r2:\n            proceed = False\n            for i in range(1,len(crossing_routes)):\n                if _route_nr == crossing_routes[i][0]:\n                    if not active_routes[crossing_routes[i][1]]:\n                        active_routes[_route_nr] = True\n                        crossed_routes[_route_nr] = False\n                        proceed = True\n                    else:\n                        crossed_routes[_route_nr] = True\n                if _route_nr == crossing_routes[i][1]:\n                    if not active_routes[crossing_routes[i][0]]:\n                        active_routes[_route_nr] = True\n                        crossed_routes[_route_nr] = False\n                        proceed = True\n                    else:\n                        crossed_routes[_route_nr] = True\n\n    return proceed\n\n\n\n#---------------------------------------------------------------------------------------------------------\n# buttons and switches\n#---------------------------------------------------------------------------------------------------------\n\ndef on_button_pressed_a():\n    global stopping, robot, DEBUG\n    stopping = False\n    robot.active = True\n    if DEBUG: serial.write_line('button pressed')\n    showText(\"ACTIVE\")\n    pass\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n\n'''\ndef on_button_pressed_b():\n    global stopping\n    stopping = True\n    if DEBUG: serial.write_line('reset')\n    pass\ninput.on_button_pressed(Button.B, on_button_pressed_b)\n'''\n\ndef leading_zeros(_num, _digits):\n    _str = '0'\n    _num = Math.round(_num)\n    if _num < 0: _num += 256\n    if _digits == 3:\n        if _num < 10 :\n            _str = '00' + str(_num)\n        elif _num < 100:\n            _str = '0' + str(_num)\n        elif _num < 1000:\n            _str = str(_num)\n    if _digits == 2:\n            if _num < 10 :\n                _str = '0' + str(_num)\n            elif _num < 100:\n                _str = str(_num)\n    return _str\n\n'''\ndef print_data():\n    global robot, DEBUG\n    if DEBUG:\n        serial.write_value(\"# \", control.device_serial_number())\n        serial.write_line(\"speed \"+robot.speed)\n        serial.write_line(\"yaw speed \"+robot.yaw_speed)\n        serial.write_line(\"distance target\"+robot.distance_to_target)\n        serial.write_value(\"state\", robot.state)\n        serial.write_line(state_names[robot.state])\n        serial.write_line(str(\"target \" ) + str(robot.target) + str(\"  \") + locationnames[robot.target])\n        serial.write_value(\"distance\", robot.distance_to_target)\n        serial.write_value(\"speed\", robot.speed)\n        _cmd = 0\n        _chk = (robot.id + _cmd + robot.state + robot.location + robot.destination + robot.target + robot.distance_to_target) % 8\n        _str = (leading_zeros(robot.id,2) + str(_cmd) + str(robot.state) +\n                    leading_zeros(robot.location,2) + leading_zeros(robot.destination,2)  + leading_zeros(robot.target,2) +\n                    leading_zeros(robot.distance_to_target,3) + leading_zeros(robot.speed,3) + str(_chk) + \"\\r\\n\")\n        serial.write_line(_str)\n        serial.write_line('--')\n    pass\nloops.every_interval(500, print_data)\n'''\n\n'''\ndef on_serial_received():\n    global stopping, robot\n    data = serial.read_line()\n    if data == 'a':\n        stopping = False\n        robot.active = True\n        serial.write_line('remotley started')\n    if data == 'b':\n        stopping = True\n        serial.write_line('remotely reset')\n    pass\n    basic.pause(100) # yield for other processes\nserial.on_data_received(serial.delimiters(Delimiters.NEW_LINE), on_serial_received)\n'''\n\ndef on_radio_received(receivedString):\n    global robot, stopping, DEBUG, RadioTxPending, WaitingForReply\n    # cmd reply\n    # 0123456\n    # 1,1,1,1\n    # optimised without string split, and earlier reject of message\n    # radio_rx_data = receivedString\n    if receivedString[0] == str(robot.id):\n        #if DEBUG: serial.write_line(\"this is for us\")\n        #if DEBUG: serial.write_line(\"rx:\" + receivedString)\n        #data = radio_rx_data.split(',')\n        #for d in range (len(data)):\n        #    if DEBUG: serial.write_line(data[d])\n        #_id = int(data[0])\n        #if _id == robot.id:\n        # this message is send for us\n        #_cmd = int(data[1])\n        _cmd = int(receivedString[2])\n        if _cmd == 0:\n            # send status report or pending command\n            #robot.cmd = STATUS_UPDATE\n            pass\n        elif _cmd == 1:\n            # NOK/OK claim destination reply\n            # data[2] = NOK/OK, data[3] = claimed id\n            #if int(data[3]) == robot.id:\n            if int(receivedString[6]) == robot.id:\n                robot.reply = OK\n                robot.cmd = 0 # no more commands\n            pass\n        elif _cmd == 2:\n            # ACK releaseposition\n            #if int(data[2]) == 2:\n            if int(receivedString[4]) == 2:\n                robot.reply = ACK\n                robot.cmd = 0\n            pass\n        elif _cmd == 3:\n            # ACK releaseroute\n            #if int(data[2]) == 2:\n            if int(receivedString[4]) == 2:\n                robot.reply = ACK\n                robot.cmd = 0\n            pass\n        elif _cmd == 4:\n            # START driving\n            stopping = False\n            robot.active = True\n            pass\n        elif _cmd == 5:\n            # STOP driving\n            stopping = True\n            robot.active = False\n            pass\n\n        RadioTxPending = True\n        WaitingForReply = False\n        #radio_transmit(robot)\n        #if DEBUG: serial.write_line(\"sending radio\")\n        yield_(5) # yield for other processes\n    pass\nradio.on_received_string(on_radio_received)\n\n\ndef radio_transmit(_robot=Robot()):\n    _cmd = _robot.cmd\n    _chk = (_robot.id + _cmd + _robot.state + _robot.location + _robot.destination + _robot.target + _robot.distance_to_target + _robot.speed) % 8\n    _str = (leading_zeros(robot.id,2) + str(_cmd) + str(robot.state) +\n                leading_zeros(robot.location,2) + leading_zeros(robot.destination,2)  + leading_zeros(robot.target,2) +\n                leading_zeros(robot.distance_to_target,3) + leading_zeros(robot.speed,3) + str(_chk) + \"\\r\\n\")\n    radio.send_string(_str)\n\n    #radio.send_string(\"id:\" + str(robot.id))\n    #radio.send_string(\",state:\" + str(robot.state))\n    #radio.send_string(str(\",loc:\" ) + str(robot.location))\n    #radio.send_string(str(\",des:\" ) + str(robot.destination))\n    #radio.send_string(str(\",tar:\" ) + str(robot.target))\n    #radio.send_string(\"\\r\\n\" )\n    #radio.send_string(str(\"target \" ) + str(robot.target) + str(\"  \") + locationnames[robot.target] + '\\r\\n')\n#loops.every_interval(250, on_every_interval)\n\ndef yield_(_t=50):\n    basic.pause(_t)\n\n\n#---------------------------------------------------------------------------------------------------------\n# actual main loop\n#---------------------------------------------------------------------------------------------------------\nstopping = False\nradio.set_group(1)\nclose_gripper()\n\nRadioTxTime = input.running_time()\nWaitingForReply = False \n\ndef on_forever():\n\n    global stopping, HIL_Simulation, robot, newdata, RadioTxPending, RadioTxTime, WaitingForReply\n    if not stopping:\n        if (robot.cmd == CLAIM_DESTINATION or robot.cmd == RELEASE_ROUTE) and not WaitingForReply:\n            if DEBUG: serial.write_line(\"radio tx\")\n            RadioTxPending = True\n        #if RadioTxPending and not WaitingForReply:\n            radio_transmit(robot) # send message\n            RadioTxPending =  False # we have send the message\n            RadioTxTime = input.running_time() # note send time\n            WaitingForReply = True # start waiting for reply\n        if WaitingForReply and (RadioTxTime - input.running_time()) > 1000: # timeout after 1 second\n            RadioTxPending = True # retry\n            WaitingForReply = False\n            RadioTxTime = input.running_time()\n            \n        if HIL_Simulation: \n            basic.pause(50)\n            newdata = True\n        if newdata:\n            newdata = False # sync to Huskylens\n            do_robot(robot)\n\n    if HIL_Simulation: basic.pause(50)\n    #print_data() -> background loop\n    if stopping:\n        robot.active = False\n        robot.location = 1\n        robot.destination = 1\n        robot.target = 1\n        robot.objecttype = None\n        robot.state = IDLE\n    pass\n    yield_(5) # yield for other processes\n\nbasic.forever(on_forever)\n\n\n\ndef on_in_background():\n    #Huskylens\n    global t_start, t_last, dt_AI, inview, tagsInView, inview_count, x, y, w, h, newdata, zeroes\n    # approx 56 ms -> ~ 18 fps\n    t_start = input.running_time()\n    t_last = t_start\n    while 1:\n        \n        t_start = input.running_time()\n        dt_AI = t_start - t_last\n        # loop time\n        t_last = t_start\n        huskylens.request()\n        #yield_(20) # yield for other processes\n        inview = huskylens.get_box(HUSKYLENSResultType_t.HUSKYLENS_RESULT_BLOCK)\n        tagsInView = zeroes\n        k = 0\n        while k < inview:\n            tagsInView[k] = huskylens.readBox_ss(k + 1, Content3.ID)\n            k += 1\n        #serial.write_line(\"gripper : \"+str(robot.gripper))\n        if huskylens.is_appear(robot.target, HUSKYLENSResultType_t.HUSKYLENS_RESULT_BLOCK):\n            x = huskylens.reade_box(robot.target, Content1.X_CENTER)\n            y = huskylens.reade_box(robot.target, Content1.Y_CENTER)\n            w = huskylens.reade_box(robot.target, Content1.WIDTH)\n            h = huskylens.reade_box(robot.target, Content1.HEIGHT)\n            inview_count = 0\n        else:\n            inview_count += 1\n            if inview_count > 5: # if 3 frames no valid tag, reset to 0\n                x = -1\n                y = -1\n                w = -1\n                h = -1\n        newdata = True\n\n                          \ncontrol.in_background(on_in_background)","pxt.json":"{\n    \"name\": \"MPPS_demonstrator_python_only_v05\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"Huskylens\": \"github:dfrobot/pxt-dfrobot_huskylens#v2.0.6\",\n        \"maqueen\": \"github:dfrobot/pxt-maqueen#v1.7.5\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.51\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1735229796762,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables></xml>","main.ts":"","README.md":"\n> Open this page at [https://artandtechvof.github.io/mpps_demonstrator_python_only_v02/](https://artandtechvof.github.io/mpps_demonstrator_python_only_v02/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/artandtechvof/mpps_demonstrator_python_only_v02** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/artandtechvof/mpps_demonstrator_python_only_v02** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n\n\n\n> Open this page at [https://artandtechvof.github.io/mpps_demonstrator_python_only_v05/](https://artandtechvof.github.io/mpps_demonstrator_python_only_v05/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/artandtechvof/mpps_demonstrator_python_only_v05** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/artandtechvof/mpps_demonstrator_python_only_v05** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","main.py":"CollisionDetection = False\nRandomDestination = True # random object or object based on own ID\nHIL_Simulation = True    # run code on \nFirstClaimDestination = True # True: wait for destination area te be cleared.\n                             # False: turn towards destination even if it is occupied\nUseFleetmanager = True\nID = 1\n\nDEBUG = False\n\nUseHusky = False\nDisplayDelay = 200\n\ndef showText(txt):\n    #if not HIL_Simulation:\n    if UseHusky:\n        txt = str(ID) + ' ' + txt\n        huskylens.clear_osd()\n        huskylens.write_osd(txt, 30, 30)\n        if HIL_Simulation: basic.pause(DisplayDelay)\n\n\n######################################\nserial.redirect_to_usb()\nserial.write_string(\"I am alive\")\nif not HIL_Simulation or UseHusky:\n    huskylens.init_i2c()\n    huskylens.init_mode(protocolAlgorithm.ALGORITHM_TAG_RECOGNITION)\n    showText(\"BOOTING\")\nbasic.pause(1000)\n######################################\n# number of robots\nnumrobots = 1\n# number of 'plastic' object types\nnumobjects = 4 # should be an even number for now\nnumtargets = numobjects\n# buffer zones for wating robots\n# 1 robot = 1 waiting\n# 2 robot = 1 waiting, 1 on storage location\n# 3 robot = 3 waiting, 1 left, 1 right 1 central\n# 4 robot = 5 waiting, 2 left, 2 right, 1 central\n# 5 robot = 7 waiting, 3 left, 3 right, 1 central\n# 6 robot = 9 waiting, 4 left, 4 right, 1 central\n# 7 robot = 11 waiting, 5 left, 5 right, 1 central\n# 8 robots = 13 waiting, 6 left, 6 right, 1 central\nif numrobots == 1:\n    numwaitingareas = 5 # adjust to demo\nelse:\n    numwaitingareas = max(3,(numrobots-1)*2 -1) # 1 central waiting area offset to the front\nnumstorage = 1 # try increasing this in future scenarios, attack waste-pile from multiple locations\n# total number of locations where robots can go\nnumlocations = numwaitingareas + numstorage + numtargets + numobjects\n\n\n# constants\nIDLE = 0\nDRIVEBACKWARD = 1\nFINDTARGET = 2\nGOTOTARGET = 3\nFINDOBJECT = 4\nGRABOBJECT = 5\n\nLOCATION_t = 0 # robot is looking for location\nOBJECT_t = 1   # robot is looking for object\n\nOPENED = 1\nCLOSED = 0\n\nAHEAD = 0\nLEFT  = 1\nRIGHT = 2\n\nMAXSPEED = 25\nMINSPEED = 15\nMINYAWSPEED = 8\nMAXYAWSPEED = 14\nBACKUPSPEED = -20\nBACKUPDISTANCE = 20\n\nOBJECT_THRESHOLD = 0 # minimum distance to object, before closing grippers\n\nstate_names = ['IDLE', 'DRIVEBACKWARD', 'FINDTARGET', 'GOTOTARGET', 'FINDOBJECT', 'GRABOBJECT']\ndirection_names = ['AHEAD', 'LEFT', 'RIGHT']\ncmd_names = ['STATUS_UPDATE','CLAIM_DESTINATION','RELEASE_POSITION','RELEASE_ROUTE','ROBOT_START','ROBOT_STOP']\nrply_names = ['NOK','OK','ACK']\n\n# commands\nSTATUS_UPDATE = 0\nCLAIM_DESTINATION = 1\nRELEASE_POSITION = 2\nRELEASE_ROUTE = 3\nROBOT_START = 4\nROBOT_STOP = 5\nNOK = 0\nOK = 1\nACK = 2\n\n#initialize variables related to huskylens\nt_start = 0\nt_last = 0\ndt_AI = 0\ninview = 0\nx = 0\ny = 0\nw = 0\nh = 0\nnewdata = False\ninview_count = 0\nRadioTxPending = False\n\ntagID = 1\n# tagIDs = [1 tm 6]\ntagSizes = [0,  85, 90, 90, 90, 85,  88,  88, 88, 88, 88,  55, 55, 55, 55] # 5x waiting, 1 central, 4 targets, 4 objects\n\ntagSize = tagSizes[tagID]\n\nzeroes = [0]\nwhile i < len(tagSizes):\n    zeroes.append(0)\n    i += 1\ntagsInView = zeroes\n#start_searching = 0\n\n\n#---------------------------------------------------------------------------------------------------------\n# helper function to open and close grippers, will be different on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef open_gripper():\n    opengripper = True\n    maqueen.servo_run(maqueen.Servos.S1, 85)\n    return opengripper\n\n\ndef close_gripper():\n    closegripper = True\n    maqueen.servo_run(maqueen.Servos.S1, 105)\n    return closegripper\n\ndef actuate_motors():\n    if HIL_Simulation: return True\n\n    left_speed = (robot.speed + robot.yaw_speed)\n    right_speed = (robot.speed + -robot.yaw_speed)\n    #serial.write_line(str(left_speed)+\" left speed\")\n    #serial.write_line(str(right_speed)+\" right speed\")\n    # set speed for motors here\n    if left_speed >=0:\n        maqueen.motor_run(maqueen.Motors.M1, maqueen.Dir.CW, left_speed)\n    else:\n        maqueen.motor_run(maqueen.Motors.M1, maqueen.Dir.CCW, -left_speed)\n    if right_speed >=0:\n       maqueen.motor_run(maqueen.Motors.M2, maqueen.Dir.CW, right_speed)\n    else:\n        maqueen.motor_run(maqueen.Motors.M2, maqueen.Dir.CCW, -right_speed)\n\n    return True\n\ndef get_time():\n    return input.running_time()\n\n#---------------------------------------------------------------------------------------------------------\n# base class of robot, can also be used on micro:Maqueen robot.\n# Robot() class, should be same for offline Simulation and actual physical demo robot\n#---------------------------------------------------------------------------------------------------------\nclass Robot:\n    def __init__(self, loc=1, dst=1, _id=1):\n        # who are we\n        self.id = _id\n        # ego location and destination nr\n        self.location = loc\n        self.destination = dst\n        self.target = dst\n        self.targettype = LOCATION_t\n        self.objecttype = None\n        # states\n        self.state = IDLE\n        self.gripper = CLOSED\n        self.speed = 0\n        self.yaw_speed = 0\n        # params\n        self.active = False\n        self.run_enable = False\n        self.steering_only = False # allowed to change heading but not driving\n        self.target_direction = AHEAD\n        self.target_inview = False  # target is in view of camera\n        self.target_locked = False # target is straight ahead\n        self.backup_distance = 0\n        self.distance_to_target = 0\n        self.backup_starttime = 0\n        self.looking_for_object = 0\n        self.route_length = 0\n        self.route_reported = False\n        self.obstacle_detected = False\n        self.cmd = 0\n        self.reply = 0\n\n    def gripper_open(self):\n        if open_gripper():\n            self.gripper = OPENED\n        pass\n\n    def gripper_close(self):\n        if close_gripper():\n            self.gripper = CLOSED\n        pass\n\n#---------------------------------------------------------------------------------------------------------\n# pre allocate robot instance as global\n#---------------------------------------------------------------------------------------------------------\nrobot = Robot( loc=ID, dst=ID, _id=ID)\n\n\n#---------------------------------------------------------------------------------------------------------\n# this function will be based on camera on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef calc_heading(_robot=Robot()):\n\n    #angle error in pixels\n    # x = position of tag in camera view, 320 wide, 160 is center\n    if HIL_Simulation:\n        basic.pause(100)\n        return 0\n        \n    angle_err = 160-x\n    \n    return angle_err\n\n\n#---------------------------------------------------------------------------------------------------------\n# this function will be based on camera on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef calc_distance(_robot=Robot()):\n    '''\n    if not _robot.state == DRIVEBACKWARD:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.dest[0]))**2 + ((_robot.position[1] - _robot.dest[1]))**2)\n    else:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.startposition[0]))**2 + ((_robot.position[1] - _robot.startposition[1]))**2)\n    '''\n    tagSize = tagSizes[_robot.target]\n    tagID = _robot.target\n    \n    if HIL_Simulation:\n        if not _robot.state == DRIVEBACKWARD:\n            distance_measured = _robot.distance_to_target - _robot.speed # drive towards target\n        else:\n            distance_measured = _robot.distance_to_target + abs(_robot.speed) # drive away from target\n    else :\n        distance_measured = tagSize - h  # height of tag - height of tag measured\n        #serial.write_line('h='+h+'tagsize:'+tagSize) # soort timeout invoeren\n    \n    distance_measured = max(distance_measured,0) # distance cannot be negative\n\n    return distance_measured\n    \n\n#---------------------------------------------------------------------------------------------------------\n# look for target and aim robot towards it, different in offline Simulation vs actual robot\n#---------------------------------------------------------------------------------------------------------\ndef find_target(_robot=Robot()):\n    # We are driving towards a location\n    if _robot.targettype == LOCATION_t:\n        _robot.target = _robot.destination\n    # We are looking for and driving to an object\n    if _robot.targettype == OBJECT_t:\n        # start looking for the object\n        _robot.target = obj[_robot.objecttype] # obj location nr will become new target\n\n    _robot.steering_only = True\n    # set preffered turning direction?\n    # actuate drive and steering\n\n    _dist = move_robot(_robot)\n    return _dist\n\n#---------------------------------------------------------------------------------------------------------\n#function to search target\n#---------------------------------------------------------------------------------------------------------\ndef pulse(_dir=LEFT,_robot=Robot()):\n    #pulsing behaviour\n    pulse_duration = 700  # Duration of one complete pulse cycle\n    active_ratio = 0.2  # Ratio of time the robot is actively turning within a pulse\n    base_speed = 15\n    speed_multiplier = 1.5\n\n    if robot.state == FINDOBJECT:\n        speed_multiplier = 1.5\n        if robot.looking_for_object == 0:\n            _robot.looking_for_object = input.running_time()\n        else:\n            time_looking = input.running_time() - _robot.looking_for_object\n            if time_looking < 2000:\n                 _dir = LEFT\n            else: _dir = RIGHT\n\n\n\n\n    #if start_searching == 0: # als\n    #    start_searching = input.running_time()\n    \n    #calculate searching time\n    #searching_time = input.running_time() - start_searching\n    # Calculate the phase of the pulse (0 to 1)\n    pulse_phase = (input.running_time() % pulse_duration) / pulse_duration\n\n    #calculate if we are in the active part of the pulse\n    is_active_pulse = pulse_phase < active_ratio\n\n    if is_active_pulse:\n        # During active pulse: turn with increased speed\n        turn_speed = base_speed * speed_multiplier\n    else:\n        # During inactive pulse: stand still\n        turn_speed = base_speed\n\n    if _dir == LEFT: turn_speed = -turn_speed\n\n    return turn_speed\n\n\n    #if payload:\n    #    speed_left *= 1.15\n    #    speed_right *= 1.15\n\n#---------------------------------------------------------------------------------------------------------\n# actual motion control, aim for target, with or without speed\n#---------------------------------------------------------------------------------------------------------\ndef move_robot(_robot=Robot()):\n\n    #check if robot is allowed to move\n    dist_err = 999 # default distance error\n    if not _robot.run_enable:\n            _robot.speed = 0\n            _robot.yaw_speed = 0\n\n    #check if target is in sight\n    if (_robot.target in tagsInView) or HIL_Simulation:\n            _robot.target_inview = True\n                                              \n                                                      \n\n    else:\n        # add timeout before target is no longer in view???\n        _robot.target_inview = False\n        _robot.target_locked = False\n\n    #if target is not in view turn around to look for target, use pulsed turning to speed up process\n    if not _robot.target_inview:\n        _robot.speed = 0\n        _robot.yaw_speed = pulse(_robot.target_direction,_robot)\n    # if target is in view\n    else:\n        # heading / steering control\n        angle_err = calc_heading(_robot) # how many pixels are we off centre\n        dist_err = calc_distance(_robot) # how many pixels are we away from target\n        _robot.distance_to_target = dist_err # store on instance of robot, for logistical and rouet handling\n\n        # heading control, simple P-control\n        Kp = 1.0\n        _robot.yaw_speed = -angle_err * Kp # simple P-control of heading angle\n        if _robot.target_locked:\n            _robot.yaw_speed = max(-MAXYAWSPEED, min(_robot.yaw_speed, MAXYAWSPEED))\n        else:\n            _robot.yaw_speed = max(-MAXYAWSPEED, min(_robot.yaw_speed, MAXYAWSPEED))\n\n        # speed control, start driving when target is almost straight ahead of robot\n        if abs(angle_err) < 10:\n            _robot.yaw_speed = 0\n            _robot.target_locked = True\n            # speed control, simple P-control\n            Kp = 2.0\n            _robot.speed = min(dist_err * Kp, MAXSPEED)\n            # drive slow when approaching an object\n            if _robot.state == GRABOBJECT: _robot.speed = min(MINSPEED, _robot.speed * Kp)\n            \n        else:\n            _robot.target_locked = False\n\n        # steering only when aiming for target\n        if _robot.steering_only:\n            _robot.speed = 0\n\n        # if obstacle detected stop robot\n        if CollisionDetection and collision_detected(_robot):\n            _robot.speed = 0\n            _robot.yaw_speed = 0\n\n        # adjust turning speed depening on driving or turning when standing still\n        if _robot.speed > 0 :\n            # while driving reduce maximum turning speed, for smoother driving\n            _robot.yaw_speed = max(-MINYAWSPEED/4, min(_robot.yaw_speed, MINYAWSPEED/4))\n\n        else:\n            # turn while standing still, use minimum turning speed\n            if  _robot.yaw_speed > 0:\n                if _robot.yaw_speed < MAXYAWSPEED: _robot.yaw_speed = MAXYAWSPEED\n            if  _robot.yaw_speed < 0:\n                if _robot.yaw_speed > -MAXYAWSPEED: _robot.yaw_speed = -MAXYAWSPEED\n\n    actuate_motors()\n    return dist_err\n\n\n#---------------------------------------------------------------------------------------------------------\n# actively stop robot\n#---------------------------------------------------------------------------------------------------------\ndef stop_robot(_robot=Robot()):\n    _robot.speed = 0\n    _robot.yaw_speed = 0\n    actuate_motors()\n\n#---------------------------------------------------------------------------------------------------------\n# drive backward to clear storage or target areas\n#---------------------------------------------------------------------------------------------------------\ndef reverse_robot(_robot=Robot()):\n    dist_err = calc_distance(_robot)\n    # drive straight backward, without steering\n    _robot.yaw_speed = 0\n    # have we driven far enough backward? distance is trigger, could also be timed reverse driving\n    if (input.running_time() - _robot.backup_starttime) < 750: # 0.75 seconds\n        _robot.looking_for_object = 0\n    #if dist_err < _robot.backup_distance:\n        _robot.speed = BACKUPSPEED\n        _finished = False\n    else:\n        _finished = True\n        _robot.speed = 0\n    actuate_motors()\n    return _finished\n\n\n#---------------------------------------------------------------------------------------------------------\n# run robot main code (similar to real-time implementation)\n#---------------------------------------------------------------------------------------------------------\ndef do_robot(_robot=Robot()):\n    # statemachine\n    if _robot.state == IDLE:\n        _robot.run_enable = False\n        _robot.speed = 0\n        _robot.yaw_speed = 0\n        _robot.cmd = STATUS_UPDATE\n        stop_robot(_robot)\n        if _robot.active:\n            # we are allowed to drive\n            _robot.run_enable = True\n            # request next destination, if we cary an object we are going to an output stream area\n            result = next_destination( _robot.destination, _robot.objecttype)\n            _robot.destination = result[0]\n            _robot.target_direction = result[1]\n            _robot.target = _robot.destination\n            # if we are in the waiting area, we do not need to back up, otherwise, backup before driving\n            if HIL_Simulation:\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n            # maybe  try to claim the location here. With QR code another robot might be in the way of seeing the QR code\n            # when the robot has reased its starting position (claim released) the QR code should be visible\n            if _robot.location in waitingarea:\n                _robot.backup_distance = 0\n                _robot.state = FINDTARGET  # directly start aiming for next destination\n                #serial.write_line(\"state find target\")\n                showText(\"FINDTARGET: \" + str(_robot.target) + ' ' + direction_names[_robot.target_direction])\n                # for HIL_Simulation only\n                if HIL_Simulation:\n                    _robot.distance_to_target = 90\n                    _robot.route_length = _robot.distance_to_target\n\n            else:\n                # backup distance\n                _robot.backup_distance = BACKUPDISTANCE\n                #serial.write_line(\"state drive backwards\")\n                showText(\"DRIVEBACKWARD\")\n                _robot.state = DRIVEBACKWARD  # drive backwards first\n                _robot.backup_starttime = get_time() # input.running_time()\n                # if wa are at target area, weh open gripper and drive backward to leave object there\n                if _robot.location in target[1:numtargets+1]:\n                    _robot.gripper_open()\n                    _robot.objecttype = None # we leave the object here\n                    pass\n                #elif _robot.location in storagearea:\n                # randomly assign new object to location where last object was taken from\n                #    nxt_object = randint(1, numobjects+1)\n                #    waste_object[_robot.objecttype].color = colorlist[nxt_object]  # we leave the object here\n                #    waste_object[_robot.objecttype].objecttype = nxt_object\n                #    pass\n                else:\n                    # all other areas we drive backward with grippers closed\n                    _robot.gripper_close()\n                    pass\n                # for HIL_Simulation only\n                if HIL_Simulation: _robot.distance_to_target = 0\n        pass\n    elif _robot.state == DRIVEBACKWARD:\n        # drive backwards\n        if reverse_robot(_robot):\n            _robot.state = FINDTARGET\n            showText(\"FINDTARGET: \" + str(_robot.target) + ' ' + direction_names[_robot.target_direction])\n            _robot.gripper_close()\n            # for HIL_Simulation only\n            if HIL_Simulation:\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n        pass\n    elif _robot.state == FINDTARGET:\n        # find target by rotating robot, but do not drive\n        _proceed = False\n        if FirstClaimDestination:\n             if UseFleetmanager:\n                 _robot.cmd = CLAIM_DESTINATION\n                 if _robot.reply == OK:\n                     _robot.reply = 0 # reset for next command\n                     _proceed = True\n                     _robot.cmd = STATUS_UPDATE\n                 pass\n             else:\n                if claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                    _proceed = True\n        else:\n            _proceed = True\n\n        if _proceed:\n            _robot.targettype = LOCATION_t\n            _dist_to_travel = find_target(_robot)\n            # when we have found the target, we are going to drive towards it\n            if _robot.target_locked:\n                # we have found the target, re-check if it is clear to drive there\n                #if CollisionDetection or claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                if not FirstClaimDestination:\n                    _proceed = False\n                    if CollisionDetection:\n                        _proceed = True\n                    elif UseFleetmanager:\n                        _robot.cmd = CLAIM_DESTINATION\n                        if _robot.reply == OK:\n                            _robot.reply = 0 # reset for next command\n                            _proceed = True\n                            _robot.cmd = STATUS_UPDATE\n                        pass\n                    elif claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                            _proceed = True\n                if _proceed:\n                    showText(\"GOTOTARGET: \" + str(_robot.target))\n                    _robot.state = GOTOTARGET\n                    _robot.route_reported = False\n                    _robot.route_length = _dist_to_travel\n                    _robot.cmd = STATUS_UPDATE\n        pass\n    elif _robot.state == GOTOTARGET:\n        # make sure we keep claim on target area\n        _robot.steering_only = False\n        _dist_to_travel = move_robot(_robot)\n        _proceed = False\n        _robot.cmd = STATUS_UPDATE\n        # report route haflway, only onetime reporting\n        if _dist_to_travel < _robot.route_length/2 and not _robot.route_reported:\n            if UseFleetmanager:\n                _robot.cmd = RELEASE_POSITION\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _robot.route_reported = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_position(_robot.location)\n                _robot.route_reported = True\n        _robot.distance_to_target = _dist_to_travel\n        # if we approach storage, open gripper before reaching destination\n        if _robot.destination in storagearea:\n            if _dist_to_travel == 0:\n                _robot.state = FINDOBJECT\n                # assign an object to look for\n                if RandomDestination:\n                    _robot.objecttype = randint(1, numobjects) # a random object is assigned to robot\n                else:\n                    _robot.objecttype = _robot.id  # robot ID determines object types to be retrieved\n                # switch state and start looking for object\n                showText(\"FINDOBJECT: \" + str(_robot.objecttype))\n                pass\n        elif _dist_to_travel <= 0:\n            # target reached, release route\n            if UseFleetmanager:\n                _proceed = False\n                _robot.cmd = RELEASE_ROUTE\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _proceed = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_route(_robot.location, _robot.destination)\n                _proceed = True\n            # update position\n            if _proceed:\n                _robot.location = _robot.destination\n                _robot.state = IDLE\n                _robot.cmd = STATUS_UPDATE\n                showText(\"IDLE\")\n        pass\n    elif _robot.state == FINDOBJECT:\n        # Finding object could be done by sweeping left and reight until object is found\n        _robot.steering_only = True\n        # if we approcah storage, open gripper before reaching destination\n        _robot.targettype = OBJECT_t\n        find_target(_robot)\n        if _robot.target_locked:\n            _robot.steering_only = False\n                                                     \n            _robot.gripper_open()\n            _robot.state = GRABOBJECT\n            showText(\"GRABOBJECT: \" + str(_robot.objecttype))\n            \n    elif _robot.state == GRABOBJECT:\n        _dist_to_travel = move_robot(_robot)\n        if _dist_to_travel <= OBJECT_THRESHOLD+5:\n                                                      \n            _robot.gripper_close()\n            _proceed = False\n            # target reached, release route\n            if UseFleetmanager:\n                _robot.cmd = RELEASE_ROUTE\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _proceed = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_route(_robot.location, _robot.destination)\n                _proceed = True\n            # update position\n            if _proceed:\n                _robot.location = _robot.destination\n                # switch to idle to start next route\n                _robot.state = IDLE\n                showText(\"IDLE\")\n        pass\n\n\n#---------------------------------------------------------------------------------------------------------\n# collision detection, can be based on camera or sensor on robot\n#---------------------------------------------------------------------------------------------------------\ndef collision_detected(_robot=Robot()):\n    #\n    # Needs implementing on robot\n    #\n    _robot.obstacle_detected = False\n    obstacle_detected = False\n    return obstacle_detected\n\n\n\n#---------------------------------------------------------------------------------------------------------\n#\n#  ROUTE HANDLING BELOW\n#\n#---------------------------------------------------------------------------------------------------------\n\n#---------------------------------------------------------------------------------------------------------\n# locations id's\n#---------------------------------------------------------------------------------------------------------\n\n# ids of waiting areas\nwaitingarea = [0]\nfor i in range(numwaitingareas):\n    waitingarea.append(i+1)\n# ids of storage areas\nstoragearea = [0]\nfor i in range(numwaitingareas, numwaitingareas+numstorage):\n    storagearea.append(i+1)\n# ids of target areas\ntarget = [0]\nfor i in range(numwaitingareas+numstorage, numwaitingareas+numstorage+numtargets):\n    target.append(i+1)\n# ids of objects\nobj = [0]\nfor i in range(numwaitingareas+numstorage+numtargets, numwaitingareas+numstorage+numtargets+numobjects):\n    obj.append(i+1)\n\n#occupation list of all locations\n#occupying = [0]  * (numlocations +1) -> does not work in Makecode\n# for compatibility reasons wit MakeCode on robot, do it like this\noccupying = [0]\nfor i in range(numlocations +1):\n    occupying.append(0)\n\nlocationnames = ['None']\nfor i in range(1,numwaitingareas+1):\n    locationnames.append(str('waitingarea ') + str(i))\nlocationnames.append(str('storage 1'))\nfor i in range(1,numobjects+1):\n    locationnames.append(str('targetarea ') + str(i))\nfor i in range(numobjects+1):\n    locationnames.append(str('object ') + str(i+1))\n\n#---------------------------------------------------------------------------------------------------------\n# instances of routes, using location id's\n#---------------------------------------------------------------------------------------------------------\nroutes = [(0,0)]\nfor i in range(50):\n    routes.append((0,0))\n\n# route automatic define from location, to location, use location numbers instead of coordinates for easier update\nfor i in range(numwaitingareas):\n    routes[i] = (waitingarea[1+i], storagearea[1])\noffset = numwaitingareas\nfor i in range(numobjects):\n    routes[i+offset] = (storagearea[1], target[1+i])\noffset += i+1\nfor i in range(numobjects):\n    if i < numobjects/2:\n        routes[i+offset] = (target[i+1], waitingarea[1])\n    else:\n        routes[i + offset] = (target[i+1], waitingarea[len(waitingarea)-1]) # waitingarea[-1] is not compatibel with Makecode\noffset += i+1\nidx = 0\nfor i in range(1, numwaitingareas):\n    if i < numwaitingareas/2:\n        routes[offset+i-1] = (waitingarea[i], waitingarea[i+1]) # shift from left to middle\n        idx = i\n    else:\n        routes[offset+i-1] = (waitingarea[len(waitingarea)-1]-i+idx+1, waitingarea[len(waitingarea)-1]-i+idx) # shift from right to middle\n\n\n# potentially crossing route combinations for additional clearance check\n# crossing routes:\n# - all routes from storage to targets in combination with all targets to waitingarea\n# - combination have to be all on left side or right side, right and left never cross (for now)\ncrossing_routes_ids = [((0,0),(0,0))]\ncrossing_routes = [(0,0)]\nfor i in range(len(routes)):\n    if routes[i][0] == storagearea[1]:\n        for j in range(len(routes)):\n            if routes[j][1] == waitingarea[1]:\n                if routes[j][0]<routes[i][1]:\n                    if routes[i][1] in target[1:int(numtargets/2)+1]:\n                        crossing_routes_ids.append((routes[i],routes[j]))\n                        crossing_routes.append((i, j))\n            if routes[j][1] == waitingarea[len(waitingarea)-1]:\n                if routes[j][0] < routes[i][1]:\n                    if routes[i][1] in target[int(numtargets/2)+1:numtargets+1]:\n                        crossing_routes_ids.append((routes[i], routes[j]))\n                        crossing_routes.append((i, j))\n\nactive_routes = [False]\nfor i in range(len(routes) +1):\n    active_routes.append(False)\ncrossed_routes = [False]\nfor i in range(len(routes) +1):\n    crossed_routes.append(False)\n\n\n#---------------------------------------------------------------------------------------------------------\n# check what next destination will be, this is the route scheduler, might be local or remote implemented\n#---------------------------------------------------------------------------------------------------------\ndef next_destination(_location, objecttype = None):\n    nxt_dest = _location # if there is no new location found, return current position as next destination\n    target_dir = AHEAD\n    # if we pick up an object, object nr tels us where to go\n    if (_location in storagearea) and (objecttype is not None):\n        # were need the collected object go to?\n        nxt_dest = target[objecttype]\n        # is target location left or rigth of us?\n        if nxt_dest in target[1:int(numtargets/2)+1]:\n            target_dir = LEFT\n        elif nxt_dest in target[int(numtargets/2)+1:numtargets+1]:\n            target_dir = RIGHT\n    # if we come from a target to the left, goto left most waiting area\n    elif _location in target[1:int(numtargets/2)+1]:\n        nxt_dest = waitingarea[1]\n        target_dir = LEFT\n    # if we come from a taget to the right, goto right most waiting area\n    elif _location in target[int(numtargets/2)+1:numtargets+1]:\n        nxt_dest = waitingarea[len(waitingarea)-1]\n        target_dir = RIGHT\n    # if we are in the waiting area, move toward the center wating area, before going back to the storage\n    elif _location in waitingarea:\n        # from waiting to storeage, unless we have to shift in the waiting area\n        nxt_dest = storagearea[1]\n        target_dir = LEFT\n        for i in range(1,int(numwaitingareas/2)+1):\n            # from left to middle\n            if _location == waitingarea[i]:\n                nxt_dest = waitingarea[i+1]\n                target_dir = LEFT\n            # from right to middle\n            if _location == waitingarea[len(waitingarea)-1]-i+1:\n                nxt_dest = waitingarea[len(waitingarea)-1]-i\n                target_dir = RIGHT\n    return nxt_dest, target_dir\n\n\n#---------------------------------------------------------------------------------------------------------\n# try to claim destination, if succesfull, returns True and own ID, if unsuccesfull returns ID that occupies the destination\n#---------------------------------------------------------------------------------------------------------\ndef claim_destination(_loc=0, _dest=0, _id=0):\n    claimed = 0\n    occupied = occupying[_dest]\n    if occupied == 0 and _id > 0:\n        occupying[_dest] = _id\n        claimed_id = _id\n        claimed = 1\n    else:\n        claimed_id = occupying[_dest]\n    if claimed_id == _id > 0:\n        if check_routes(_loc, _dest, _id):\n            occupying[_dest] = _id\n            #release_position(_loc) # this assumes that you start driving imediatly after claim of location\n        else:\n            claimed_id = 0\n    return claimed, claimed_id\n\n\n#---------------------------------------------------------------------------------------------------------\n# check if a destination is occupied, return ID that occupies destination\n#---------------------------------------------------------------------------------------------------------\ndef check_occupied(_dst):\n    claimed, occupied = claim_destination(_dest=_dst)\n    return occupied\n\n\n#---------------------------------------------------------------------------------------------------------\n# release location when you have left it\n#---------------------------------------------------------------------------------------------------------\ndef release_position(_location):\n    occupying[_location] = 0\n    return True\n\n\n#---------------------------------------------------------------------------------------------------------\n# release a route when we finished driving it\n#---------------------------------------------------------------------------------------------------------\ndef release_route(_loc,_dest):\n    _route = (_loc,_dest)\n    #if _route in [r for r in routes]: # not compatible with makecode\n    _found = False\n    for i in range(len(routes)):\n        if _route == routes[i]: _found = True\n    if _found:\n        # get route nr\n        _route_nr = routes.index(_route)\n        active_routes[_route_nr] = False\n    # check if route is actually released before returning -> need for remote implementation\n    while active_routes[_route_nr]:\n        # keep on trying to release the route\n        pass\n\n\n\n#---------------------------------------------------------------------------------------------------------\n# check if routes are crossing, claim route if crossing path is free\n#---------------------------------------------------------------------------------------------------------\ndef check_routes(_loc, _dest, _id):\n    if CollisionDetection: return True\n    proceed = True\n    # check start location of route\n    # is route valid and in route list]\n    _route = (_loc,_dest)\n    #if _route in [r for r in routes]: # not compatible with makecode\n    _found = False\n    for i in range(len(routes)):\n        if _route == routes[i] and routes[i] != (0, 0):\n            _found = True\n    if _found:\n        # get route nr\n        _route_nr = routes.index(_route)\n        #_r1 = _route_nr in [r[0] for r in crossing_routes]  # not compatible with makecode\n        #_r2 = _route_nr in [r[1] for r in crossing_routes] # not compatible with makecode\n        _r1 = False\n        _r2 = False\n        for i in range(1,len(crossing_routes)):\n            if _route_nr == crossing_routes[i][0]: _r1 = True\n            if _route_nr == crossing_routes[i][1]: _r2 = True\n        if _r1 or _r2:\n            proceed = False\n            for i in range(1,len(crossing_routes)):\n                if _route_nr == crossing_routes[i][0]:\n                    if not active_routes[crossing_routes[i][1]]:\n                        active_routes[_route_nr] = True\n                        crossed_routes[_route_nr] = False\n                        proceed = True\n                    else:\n                        crossed_routes[_route_nr] = True\n                if _route_nr == crossing_routes[i][1]:\n                    if not active_routes[crossing_routes[i][0]]:\n                        active_routes[_route_nr] = True\n                        crossed_routes[_route_nr] = False\n                        proceed = True\n                    else:\n                        crossed_routes[_route_nr] = True\n\n    return proceed\n\n\n\n#---------------------------------------------------------------------------------------------------------\n# buttons and switches\n#---------------------------------------------------------------------------------------------------------\n\ndef on_button_pressed_a():\n    global stopping, robot, DEBUG\n    stopping = False\n    robot.active = True\n    if DEBUG: serial.write_line('button pressed')\n    showText(\"ACTIVE\")\n    pass\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n\n'''\ndef on_button_pressed_b():\n    global stopping\n    stopping = True\n    if DEBUG: serial.write_line('reset')\n    pass\ninput.on_button_pressed(Button.B, on_button_pressed_b)\n'''\n\ndef leading_zeros(_num, _digits):\n    _str = '0'\n    _num = Math.round(_num)\n    if _num < 0: _num += 256\n    if _digits == 3:\n        if _num < 10 :\n            _str = '00' + str(_num)\n        elif _num < 100:\n            _str = '0' + str(_num)\n        elif _num < 1000:\n            _str = str(_num)\n    if _digits == 2:\n            if _num < 10 :\n                _str = '0' + str(_num)\n            elif _num < 100:\n                _str = str(_num)\n    return _str\n\n'''\ndef print_data():\n    global robot, DEBUG\n    if DEBUG:\n        serial.write_value(\"# \", control.device_serial_number())\n        serial.write_line(\"speed \"+robot.speed)\n        serial.write_line(\"yaw speed \"+robot.yaw_speed)\n        serial.write_line(\"distance target\"+robot.distance_to_target)\n        serial.write_value(\"state\", robot.state)\n        serial.write_line(state_names[robot.state])\n        serial.write_line(str(\"target \" ) + str(robot.target) + str(\"  \") + locationnames[robot.target])\n        serial.write_value(\"distance\", robot.distance_to_target)\n        serial.write_value(\"speed\", robot.speed)\n        _cmd = 0\n        _chk = (robot.id + _cmd + robot.state + robot.location + robot.destination + robot.target + robot.distance_to_target) % 8\n        _str = (leading_zeros(robot.id,2) + str(_cmd) + str(robot.state) +\n                    leading_zeros(robot.location,2) + leading_zeros(robot.destination,2)  + leading_zeros(robot.target,2) +\n                    leading_zeros(robot.distance_to_target,3) + leading_zeros(robot.speed,3) + str(_chk) + \"\\r\\n\")\n        serial.write_line(_str)\n        serial.write_line('--')\n    pass\nloops.every_interval(500, print_data)\n'''\n\n'''\ndef on_serial_received():\n    global stopping, robot\n    data = serial.read_line()\n    if data == 'a':\n        stopping = False\n        robot.active = True\n        serial.write_line('remotley started')\n    if data == 'b':\n        stopping = True\n        serial.write_line('remotely reset')\n    pass\n    basic.pause(100) # yield for other processes\nserial.on_data_received(serial.delimiters(Delimiters.NEW_LINE), on_serial_received)\n'''\n\ndef on_radio_received(receivedString):\n    global robot, stopping, DEBUG, RadioTxPending, WaitingForReply\n    # cmd reply\n    # 0123456\n    # 1,1,1,1\n    # optimised without string split, and earlier reject of message\n    # radio_rx_data = receivedString\n    if receivedString[0] == str(robot.id):\n        #if DEBUG: serial.write_line(\"this is for us\")\n        #if DEBUG: serial.write_line(\"rx:\" + receivedString)\n        #data = radio_rx_data.split(',')\n        #for d in range (len(data)):\n        #    if DEBUG: serial.write_line(data[d])\n        #_id = int(data[0])\n        #if _id == robot.id:\n        # this message is send for us\n        #_cmd = int(data[1])\n        _cmd = int(receivedString[2])\n        if _cmd == 0:\n            # send status report or pending command\n            #robot.cmd = STATUS_UPDATE\n            pass\n        elif _cmd == 1:\n            # NOK/OK claim destination reply\n            # data[2] = NOK/OK, data[3] = claimed id\n            #if int(data[3]) == robot.id:\n            if int(receivedString[6]) == robot.id:\n                robot.reply = OK\n                robot.cmd = 0 # no more commands\n            pass\n        elif _cmd == 2:\n            # ACK releaseposition\n            #if int(data[2]) == 2:\n            if int(receivedString[4]) == 2:\n                robot.reply = ACK\n                robot.cmd = 0\n            pass\n        elif _cmd == 3:\n            # ACK releaseroute\n            #if int(data[2]) == 2:\n            if int(receivedString[4]) == 2:\n                robot.reply = ACK\n                robot.cmd = 0\n            pass\n        elif _cmd == 4:\n            # START driving\n            stopping = False\n            robot.active = True\n            pass\n        elif _cmd == 5:\n            # STOP driving\n            stopping = True\n            robot.active = False\n            pass\n\n        RadioTxPending = True\n        WaitingForReply = False\n        #radio_transmit(robot)\n        #if DEBUG: serial.write_line(\"sending radio\")\n        yield_(5) # yield for other processes\n    pass\nradio.on_received_string(on_radio_received)\n\n\ndef radio_transmit(_robot=Robot()):\n    _cmd = _robot.cmd\n    _chk = (_robot.id + _cmd + _robot.state + _robot.location + _robot.destination + _robot.target + _robot.distance_to_target + _robot.speed) % 8\n    _str = (leading_zeros(robot.id,2) + str(_cmd) + str(robot.state) +\n                leading_zeros(robot.location,2) + leading_zeros(robot.destination,2)  + leading_zeros(robot.target,2) +\n                leading_zeros(robot.distance_to_target,3) + leading_zeros(robot.speed,3) + str(_chk) + \"\\r\\n\")\n    radio.send_string(_str)\n\n    #radio.send_string(\"id:\" + str(robot.id))\n    #radio.send_string(\",state:\" + str(robot.state))\n    #radio.send_string(str(\",loc:\" ) + str(robot.location))\n    #radio.send_string(str(\",des:\" ) + str(robot.destination))\n    #radio.send_string(str(\",tar:\" ) + str(robot.target))\n    #radio.send_string(\"\\r\\n\" )\n    #radio.send_string(str(\"target \" ) + str(robot.target) + str(\"  \") + locationnames[robot.target] + '\\r\\n')\n#loops.every_interval(250, on_every_interval)\n\ndef yield_(_t=50):\n    basic.pause(_t)\n\n\n#---------------------------------------------------------------------------------------------------------\n# actual main loop\n#---------------------------------------------------------------------------------------------------------\nstopping = False\nradio.set_group(1)\nclose_gripper()\n\nRadioTxTime = input.running_time()\nWaitingForReply = False \n\ndef on_forever():\n\n    global stopping, HIL_Simulation, robot, newdata, RadioTxPending, RadioTxTime, WaitingForReply\n    if not stopping:\n        if (robot.cmd == CLAIM_DESTINATION or robot.cmd == RELEASE_ROUTE) and not WaitingForReply:\n            if DEBUG: serial.write_line(\"radio tx\")\n            RadioTxPending = True\n        #if RadioTxPending and not WaitingForReply:\n            radio_transmit(robot) # send message\n            RadioTxPending =  False # we have send the message\n            RadioTxTime = input.running_time() # note send time\n            WaitingForReply = True # start waiting for reply\n        if WaitingForReply and (RadioTxTime - input.running_time()) > 1000: # timeout after 1 second\n            RadioTxPending = True # retry\n            WaitingForReply = False\n            RadioTxTime = input.running_time()\n            \n        if HIL_Simulation: \n            basic.pause(50)\n            newdata = True\n        if newdata:\n            newdata = False # sync to Huskylens\n            do_robot(robot)\n\n    if HIL_Simulation: basic.pause(50)\n    #print_data() -> background loop\n    if stopping:\n        robot.active = False\n        robot.location = 1\n        robot.destination = 1\n        robot.target = 1\n        robot.objecttype = None\n        robot.state = IDLE\n    pass\n    yield_(5) # yield for other processes\n\nbasic.forever(on_forever)\n\n\n\ndef on_in_background():\n    #Huskylens\n    global t_start, t_last, dt_AI, inview, tagsInView, inview_count, x, y, w, h, newdata, zeroes\n    # approx 56 ms -> ~ 18 fps\n    t_start = input.running_time()\n    t_last = t_start\n    while 1:\n        \n        t_start = input.running_time()\n        dt_AI = t_start - t_last\n        # loop time\n        t_last = t_start\n        huskylens.request()\n        #yield_(20) # yield for other processes\n        inview = huskylens.get_box(HUSKYLENSResultType_t.HUSKYLENS_RESULT_BLOCK)\n        tagsInView = zeroes\n        k = 0\n        while k < inview:\n            tagsInView[k] = huskylens.readBox_ss(k + 1, Content3.ID)\n            k += 1\n        #serial.write_line(\"gripper : \"+str(robot.gripper))\n        if huskylens.is_appear(robot.target, HUSKYLENSResultType_t.HUSKYLENS_RESULT_BLOCK):\n            x = huskylens.reade_box(robot.target, Content1.X_CENTER)\n            y = huskylens.reade_box(robot.target, Content1.Y_CENTER)\n            w = huskylens.reade_box(robot.target, Content1.WIDTH)\n            h = huskylens.reade_box(robot.target, Content1.HEIGHT)\n            inview_count = 0\n        else:\n            inview_count += 1\n            if inview_count > 5: # if 3 frames no valid tag, reset to 0\n                x = -1\n                y = -1\n                w = -1\n                h = -1\n        newdata = True\n\n                          \ncontrol.in_background(on_in_background)","pxt.json":"{\n    \"name\": \"MPPS_demonstrator_python_only_v06\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"Huskylens\": \"github:dfrobot/pxt-dfrobot_huskylens#v2.0.6\",\n        \"maqueen\": \"github:dfrobot/pxt-maqueen#v1.7.5\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.51\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1735231655654,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables></xml>","main.ts":"","README.md":"\n> Open this page at [https://artandtechvof.github.io/mpps_demonstrator_python_only_v02/](https://artandtechvof.github.io/mpps_demonstrator_python_only_v02/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/artandtechvof/mpps_demonstrator_python_only_v02** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/artandtechvof/mpps_demonstrator_python_only_v02** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n\n\n\n> Open this page at [https://artandtechvof.github.io/mpps_demonstrator_python_only_v05/](https://artandtechvof.github.io/mpps_demonstrator_python_only_v05/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/artandtechvof/mpps_demonstrator_python_only_v05** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/artandtechvof/mpps_demonstrator_python_only_v05** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","main.py":"CollisionDetection = False\nRandomDestination = True # random object or object based on own ID\nHIL_Simulation = True    # run code on \nFirstClaimDestination = True # True: wait for destination area te be cleared.\n                             # False: turn towards destination even if it is occupied\nUseFleetmanager = True\nID = 1\n\nDEBUG = True\n\nUseHusky = False\nDisplayDelay = 200\n\ndef showText(txt):\n    #if not HIL_Simulation:\n    if UseHusky:\n        txt = str(ID) + ' ' + txt\n        huskylens.clear_osd()\n        huskylens.write_osd(txt, 30, 30)\n        if HIL_Simulation: basic.pause(DisplayDelay)\n\n\n######################################\nserial.redirect_to_usb()\nserial.write_string(\"I am alive\")\nif not HIL_Simulation or UseHusky:\n    huskylens.init_i2c()\n    huskylens.init_mode(protocolAlgorithm.ALGORITHM_TAG_RECOGNITION)\n    showText(\"BOOTING\")\nbasic.pause(1000)\n######################################\n# number of robots\nnumrobots = 1\n# number of 'plastic' object types\nnumobjects = 4 # should be an even number for now\nnumtargets = numobjects\n# buffer zones for wating robots\n# 1 robot = 1 waiting\n# 2 robot = 1 waiting, 1 on storage location\n# 3 robot = 3 waiting, 1 left, 1 right 1 central\n# 4 robot = 5 waiting, 2 left, 2 right, 1 central\n# 5 robot = 7 waiting, 3 left, 3 right, 1 central\n# 6 robot = 9 waiting, 4 left, 4 right, 1 central\n# 7 robot = 11 waiting, 5 left, 5 right, 1 central\n# 8 robots = 13 waiting, 6 left, 6 right, 1 central\nif numrobots == 1:\n    numwaitingareas = 5 # adjust to demo\nelse:\n    numwaitingareas = max(3,(numrobots-1)*2 -1) # 1 central waiting area offset to the front\nnumstorage = 1 # try increasing this in future scenarios, attack waste-pile from multiple locations\n# total number of locations where robots can go\nnumlocations = numwaitingareas + numstorage + numtargets + numobjects\n\n\n# constants\nIDLE = 0\nDRIVEBACKWARD = 1\nFINDTARGET = 2\nGOTOTARGET = 3\nFINDOBJECT = 4\nGRABOBJECT = 5\n\nLOCATION_t = 0 # robot is looking for location\nOBJECT_t = 1   # robot is looking for object\n\nOPENED = 1\nCLOSED = 0\n\nAHEAD = 0\nLEFT  = 1\nRIGHT = 2\n\nMAXSPEED = 25\nMINSPEED = 15\nMINYAWSPEED = 8\nMAXYAWSPEED = 14\nBACKUPSPEED = -20\nBACKUPDISTANCE = 20\n\nOBJECT_THRESHOLD = 0 # minimum distance to object, before closing grippers\n\nstate_names = ['IDLE', 'DRIVEBACKWARD', 'FINDTARGET', 'GOTOTARGET', 'FINDOBJECT', 'GRABOBJECT']\ndirection_names = ['AHEAD', 'LEFT', 'RIGHT']\ncmd_names = ['STATUS_UPDATE','CLAIM_DESTINATION','RELEASE_POSITION','RELEASE_ROUTE','ROBOT_START','ROBOT_STOP']\nrply_names = ['NOK','OK','ACK']\n\n# commands\nSTATUS_UPDATE = 0\nCLAIM_DESTINATION = 1\nRELEASE_POSITION = 2\nRELEASE_ROUTE = 3\nROBOT_START = 4\nROBOT_STOP = 5\nNOK = 0\nOK = 1\nACK = 2\n\n#initialize variables related to huskylens\nt_start = 0\nt_last = 0\ndt_AI = 0\ninview = 0\nx = 0\ny = 0\nw = 0\nh = 0\nnewdata = False\ninview_count = 0\nRadioTxPending = False\n\ntagID = 1\n# tagIDs = [1 tm 6]\ntagSizes = [0,  85, 90, 90, 90, 85,  88,  88, 88, 88, 88,  55, 55, 55, 55] # 5x waiting, 1 central, 4 targets, 4 objects\n\ntagSize = tagSizes[tagID]\n\nzeroes = [0]\nwhile i < len(tagSizes):\n    zeroes.append(0)\n    i += 1\ntagsInView = zeroes\n#start_searching = 0\n\n\n#---------------------------------------------------------------------------------------------------------\n# helper function to open and close grippers, will be different on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef open_gripper():\n    opengripper = True\n    maqueen.servo_run(maqueen.Servos.S1, 85)\n    return opengripper\n\n\ndef close_gripper():\n    closegripper = True\n    maqueen.servo_run(maqueen.Servos.S1, 105)\n    return closegripper\n\ndef actuate_motors():\n    if HIL_Simulation: return True\n\n    left_speed = (robot.speed + robot.yaw_speed)\n    right_speed = (robot.speed + -robot.yaw_speed)\n    #serial.write_line(str(left_speed)+\" left speed\")\n    #serial.write_line(str(right_speed)+\" right speed\")\n    # set speed for motors here\n    if left_speed >=0:\n        maqueen.motor_run(maqueen.Motors.M1, maqueen.Dir.CW, left_speed)\n    else:\n        maqueen.motor_run(maqueen.Motors.M1, maqueen.Dir.CCW, -left_speed)\n    if right_speed >=0:\n       maqueen.motor_run(maqueen.Motors.M2, maqueen.Dir.CW, right_speed)\n    else:\n        maqueen.motor_run(maqueen.Motors.M2, maqueen.Dir.CCW, -right_speed)\n\n    return True\n\ndef get_time():\n    return input.running_time()\n\n#---------------------------------------------------------------------------------------------------------\n# base class of robot, can also be used on micro:Maqueen robot.\n# Robot() class, should be same for offline Simulation and actual physical demo robot\n#---------------------------------------------------------------------------------------------------------\nclass Robot:\n    def __init__(self, loc=1, dst=1, _id=1):\n        # who are we\n        self.id = _id\n        # ego location and destination nr\n        self.location = loc\n        self.destination = dst\n        self.target = dst\n        self.targettype = LOCATION_t\n        self.objecttype = None\n        # states\n        self.state = IDLE\n        self.gripper = CLOSED\n        self.speed = 0\n        self.yaw_speed = 0\n        # params\n        self.active = False\n        self.run_enable = False\n        self.steering_only = False # allowed to change heading but not driving\n        self.target_direction = AHEAD\n        self.target_inview = False  # target is in view of camera\n        self.target_locked = False # target is straight ahead\n        self.backup_distance = 0\n        self.distance_to_target = 0\n        self.backup_starttime = 0\n        self.looking_for_object = 0\n        self.route_length = 0\n        self.route_reported = False\n        self.obstacle_detected = False\n        self.cmd = 0\n        self.reply = 0\n\n    def gripper_open(self):\n        if open_gripper():\n            self.gripper = OPENED\n        pass\n\n    def gripper_close(self):\n        if close_gripper():\n            self.gripper = CLOSED\n        pass\n\n#---------------------------------------------------------------------------------------------------------\n# pre allocate robot instance as global\n#---------------------------------------------------------------------------------------------------------\nrobot = Robot( loc=ID, dst=ID, _id=ID)\n\n\n#---------------------------------------------------------------------------------------------------------\n# this function will be based on camera on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef calc_heading(_robot=Robot()):\n\n    #angle error in pixels\n    # x = position of tag in camera view, 320 wide, 160 is center\n    if HIL_Simulation:\n        basic.pause(100)\n        return 0\n        \n    angle_err = 160-x\n    \n    return angle_err\n\n\n#---------------------------------------------------------------------------------------------------------\n# this function will be based on camera on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef calc_distance(_robot=Robot()):\n    '''\n    if not _robot.state == DRIVEBACKWARD:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.dest[0]))**2 + ((_robot.position[1] - _robot.dest[1]))**2)\n    else:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.startposition[0]))**2 + ((_robot.position[1] - _robot.startposition[1]))**2)\n    '''\n    tagSize = tagSizes[_robot.target]\n    tagID = _robot.target\n    \n    if HIL_Simulation:\n        if not _robot.state == DRIVEBACKWARD:\n            distance_measured = _robot.distance_to_target - _robot.speed # drive towards target\n        else:\n            distance_measured = _robot.distance_to_target + abs(_robot.speed) # drive away from target\n    else :\n        distance_measured = tagSize - h  # height of tag - height of tag measured\n        #serial.write_line('h='+h+'tagsize:'+tagSize) # soort timeout invoeren\n    \n    distance_measured = max(distance_measured,0) # distance cannot be negative\n\n    return distance_measured\n    \n\n#---------------------------------------------------------------------------------------------------------\n# look for target and aim robot towards it, different in offline Simulation vs actual robot\n#---------------------------------------------------------------------------------------------------------\ndef find_target(_robot=Robot()):\n    # We are driving towards a location\n    if _robot.targettype == LOCATION_t:\n        _robot.target = _robot.destination\n    # We are looking for and driving to an object\n    if _robot.targettype == OBJECT_t:\n        # start looking for the object\n        _robot.target = obj[_robot.objecttype] # obj location nr will become new target\n\n    _robot.steering_only = True\n    # set preffered turning direction?\n    # actuate drive and steering\n\n    _dist = move_robot(_robot)\n    return _dist\n\n#---------------------------------------------------------------------------------------------------------\n#function to search target\n#---------------------------------------------------------------------------------------------------------\ndef pulse(_dir=LEFT,_robot=Robot()):\n    #pulsing behaviour\n    pulse_duration = 700  # Duration of one complete pulse cycle\n    active_ratio = 0.2  # Ratio of time the robot is actively turning within a pulse\n    base_speed = 15\n    speed_multiplier = 1.5\n\n    if robot.state == FINDOBJECT:\n        speed_multiplier = 1.5\n        if robot.looking_for_object == 0:\n            _robot.looking_for_object = input.running_time()\n        else:\n            time_looking = input.running_time() - _robot.looking_for_object\n            if time_looking < 2000:\n                 _dir = LEFT\n            else: _dir = RIGHT\n\n\n\n\n    #if start_searching == 0: # als\n    #    start_searching = input.running_time()\n    \n    #calculate searching time\n    #searching_time = input.running_time() - start_searching\n    # Calculate the phase of the pulse (0 to 1)\n    pulse_phase = (input.running_time() % pulse_duration) / pulse_duration\n\n    #calculate if we are in the active part of the pulse\n    is_active_pulse = pulse_phase < active_ratio\n\n    if is_active_pulse:\n        # During active pulse: turn with increased speed\n        turn_speed = base_speed * speed_multiplier\n    else:\n        # During inactive pulse: stand still\n        turn_speed = base_speed\n\n    if _dir == LEFT: turn_speed = -turn_speed\n\n    return turn_speed\n\n\n    #if payload:\n    #    speed_left *= 1.15\n    #    speed_right *= 1.15\n\n#---------------------------------------------------------------------------------------------------------\n# actual motion control, aim for target, with or without speed\n#---------------------------------------------------------------------------------------------------------\ndef move_robot(_robot=Robot()):\n\n    #check if robot is allowed to move\n    dist_err = 999 # default distance error\n    if not _robot.run_enable:\n            _robot.speed = 0\n            _robot.yaw_speed = 0\n\n    #check if target is in sight\n    if (_robot.target in tagsInView) or HIL_Simulation:\n            _robot.target_inview = True\n                                              \n                                                      \n\n    else:\n        # add timeout before target is no longer in view???\n        _robot.target_inview = False\n        _robot.target_locked = False\n\n    #if target is not in view turn around to look for target, use pulsed turning to speed up process\n    if not _robot.target_inview:\n        _robot.speed = 0\n        _robot.yaw_speed = pulse(_robot.target_direction,_robot)\n    # if target is in view\n    else:\n        # heading / steering control\n        angle_err = calc_heading(_robot) # how many pixels are we off centre\n        dist_err = calc_distance(_robot) # how many pixels are we away from target\n        _robot.distance_to_target = dist_err # store on instance of robot, for logistical and rouet handling\n\n        # heading control, simple P-control\n        Kp = 1.0\n        _robot.yaw_speed = -angle_err * Kp # simple P-control of heading angle\n        if _robot.target_locked:\n            _robot.yaw_speed = max(-MAXYAWSPEED, min(_robot.yaw_speed, MAXYAWSPEED))\n        else:\n            _robot.yaw_speed = max(-MAXYAWSPEED, min(_robot.yaw_speed, MAXYAWSPEED))\n\n        # speed control, start driving when target is almost straight ahead of robot\n        if abs(angle_err) < 10:\n            _robot.yaw_speed = 0\n            _robot.target_locked = True\n            # speed control, simple P-control\n            Kp = 2.0\n            _robot.speed = min(dist_err * Kp, MAXSPEED)\n            # drive slow when approaching an object\n            if _robot.state == GRABOBJECT: _robot.speed = min(MINSPEED, _robot.speed * Kp)\n            \n        else:\n            _robot.target_locked = False\n\n        # steering only when aiming for target\n        if _robot.steering_only:\n            _robot.speed = 0\n\n        # if obstacle detected stop robot\n        if CollisionDetection and collision_detected(_robot):\n            _robot.speed = 0\n            _robot.yaw_speed = 0\n\n        # adjust turning speed depening on driving or turning when standing still\n        if _robot.speed > 0 :\n            # while driving reduce maximum turning speed, for smoother driving\n            _robot.yaw_speed = max(-MINYAWSPEED/4, min(_robot.yaw_speed, MINYAWSPEED/4))\n\n        else:\n            # turn while standing still, use minimum turning speed\n            if  _robot.yaw_speed > 0:\n                if _robot.yaw_speed < MAXYAWSPEED: _robot.yaw_speed = MAXYAWSPEED\n            if  _robot.yaw_speed < 0:\n                if _robot.yaw_speed > -MAXYAWSPEED: _robot.yaw_speed = -MAXYAWSPEED\n\n    actuate_motors()\n    return dist_err\n\n\n#---------------------------------------------------------------------------------------------------------\n# actively stop robot\n#---------------------------------------------------------------------------------------------------------\ndef stop_robot(_robot=Robot()):\n    _robot.speed = 0\n    _robot.yaw_speed = 0\n    actuate_motors()\n\n#---------------------------------------------------------------------------------------------------------\n# drive backward to clear storage or target areas\n#---------------------------------------------------------------------------------------------------------\ndef reverse_robot(_robot=Robot()):\n    dist_err = calc_distance(_robot)\n    # drive straight backward, without steering\n    _robot.yaw_speed = 0\n    # have we driven far enough backward? distance is trigger, could also be timed reverse driving\n    if (input.running_time() - _robot.backup_starttime) < 750: # 0.75 seconds\n        _robot.looking_for_object = 0\n    #if dist_err < _robot.backup_distance:\n        _robot.speed = BACKUPSPEED\n        _finished = False\n    else:\n        _finished = True\n        _robot.speed = 0\n    actuate_motors()\n    return _finished\n\n\n#---------------------------------------------------------------------------------------------------------\n# run robot main code (similar to real-time implementation)\n#---------------------------------------------------------------------------------------------------------\ndef do_robot(_robot=Robot()):\n    # statemachine\n    if _robot.state == IDLE:\n        _robot.run_enable = False\n        _robot.speed = 0\n        _robot.yaw_speed = 0\n        _robot.cmd = STATUS_UPDATE\n        stop_robot(_robot)\n        if _robot.active:\n            # we are allowed to drive\n            _robot.run_enable = True\n            # request next destination, if we cary an object we are going to an output stream area\n            result = next_destination( _robot.destination, _robot.objecttype)\n            _robot.destination = result[0]\n            _robot.target_direction = result[1]\n            _robot.target = _robot.destination\n            # if we are in the waiting area, we do not need to back up, otherwise, backup before driving\n            if HIL_Simulation:\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n            # maybe  try to claim the location here. With QR code another robot might be in the way of seeing the QR code\n            # when the robot has reased its starting position (claim released) the QR code should be visible\n            if _robot.location in waitingarea:\n                _robot.backup_distance = 0\n                _robot.state = FINDTARGET  # directly start aiming for next destination\n                #serial.write_line(\"state find target\")\n                showText(\"FINDTARGET: \" + str(_robot.target) + ' ' + direction_names[_robot.target_direction])\n                # for HIL_Simulation only\n                if HIL_Simulation:\n                    _robot.distance_to_target = 90\n                    _robot.route_length = _robot.distance_to_target\n\n            else:\n                # backup distance\n                _robot.backup_distance = BACKUPDISTANCE\n                #serial.write_line(\"state drive backwards\")\n                showText(\"DRIVEBACKWARD\")\n                _robot.state = DRIVEBACKWARD  # drive backwards first\n                _robot.backup_starttime = get_time() # input.running_time()\n                # if wa are at target area, weh open gripper and drive backward to leave object there\n                if _robot.location in target[1:numtargets+1]:\n                    _robot.gripper_open()\n                    _robot.objecttype = None # we leave the object here\n                    pass\n                #elif _robot.location in storagearea:\n                # randomly assign new object to location where last object was taken from\n                #    nxt_object = randint(1, numobjects+1)\n                #    waste_object[_robot.objecttype].color = colorlist[nxt_object]  # we leave the object here\n                #    waste_object[_robot.objecttype].objecttype = nxt_object\n                #    pass\n                else:\n                    # all other areas we drive backward with grippers closed\n                    _robot.gripper_close()\n                    pass\n                # for HIL_Simulation only\n                if HIL_Simulation: _robot.distance_to_target = 0\n        pass\n    elif _robot.state == DRIVEBACKWARD:\n        # drive backwards\n        if reverse_robot(_robot):\n            _robot.state = FINDTARGET\n            showText(\"FINDTARGET: \" + str(_robot.target) + ' ' + direction_names[_robot.target_direction])\n            _robot.gripper_close()\n            # for HIL_Simulation only\n            if HIL_Simulation:\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n        pass\n    elif _robot.state == FINDTARGET:\n        # find target by rotating robot, but do not drive\n        _proceed = False\n        if FirstClaimDestination:\n             if UseFleetmanager:\n                 _robot.cmd = CLAIM_DESTINATION\n                 if _robot.reply == OK:\n                     _robot.reply = 0 # reset for next command\n                     _proceed = True\n                     _robot.cmd = STATUS_UPDATE\n                 pass\n             else:\n                if claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                    _proceed = True\n        else:\n            _proceed = True\n\n        if _proceed:\n            _robot.targettype = LOCATION_t\n            _dist_to_travel = find_target(_robot)\n            # when we have found the target, we are going to drive towards it\n            if _robot.target_locked:\n                # we have found the target, re-check if it is clear to drive there\n                #if CollisionDetection or claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                if not FirstClaimDestination:\n                    _proceed = False\n                    if CollisionDetection:\n                        _proceed = True\n                    elif UseFleetmanager:\n                        _robot.cmd = CLAIM_DESTINATION\n                        if _robot.reply == OK:\n                            _robot.reply = 0 # reset for next command\n                            _proceed = True\n                            _robot.cmd = STATUS_UPDATE\n                        pass\n                    elif claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                            _proceed = True\n                if _proceed:\n                    showText(\"GOTOTARGET: \" + str(_robot.target))\n                    _robot.state = GOTOTARGET\n                    _robot.route_reported = False\n                    _robot.route_length = _dist_to_travel\n                    _robot.cmd = STATUS_UPDATE\n        pass\n    elif _robot.state == GOTOTARGET:\n        # make sure we keep claim on target area\n        _robot.steering_only = False\n        _dist_to_travel = move_robot(_robot)\n        _proceed = False\n        _robot.cmd = STATUS_UPDATE\n        # report route haflway, only onetime reporting\n        if _dist_to_travel < _robot.route_length/2 and not _robot.route_reported:\n            if UseFleetmanager:\n                _robot.cmd = RELEASE_POSITION\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _robot.route_reported = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_position(_robot.location)\n                _robot.route_reported = True\n        _robot.distance_to_target = _dist_to_travel\n        # if we approach storage, open gripper before reaching destination\n        if _robot.destination in storagearea:\n            if _dist_to_travel == 0:\n                _robot.state = FINDOBJECT\n                # assign an object to look for\n                if RandomDestination:\n                    _robot.objecttype = randint(1, numobjects) # a random object is assigned to robot\n                else:\n                    _robot.objecttype = _robot.id  # robot ID determines object types to be retrieved\n                # switch state and start looking for object\n                showText(\"FINDOBJECT: \" + str(_robot.objecttype))\n                pass\n        elif _dist_to_travel <= 0+5:\n            # target reached, release route\n            if UseFleetmanager:\n                _proceed = False\n                _robot.cmd = RELEASE_ROUTE\n                if DEBUG: serial.write_line(\"release route gototarget\")\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _proceed = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_route(_robot.location, _robot.destination)\n                _proceed = True\n            # update position\n            if _proceed:\n                _robot.location = _robot.destination\n                _robot.state = IDLE\n                _robot.cmd = STATUS_UPDATE\n                showText(\"IDLE\")\n        pass\n    elif _robot.state == FINDOBJECT:\n        # Finding object could be done by sweeping left and reight until object is found\n        _robot.steering_only = True\n        # if we approcah storage, open gripper before reaching destination\n        _robot.targettype = OBJECT_t\n        find_target(_robot)\n        if _robot.target_locked:\n            _robot.steering_only = False\n                                                     \n            _robot.gripper_open()\n            _robot.state = GRABOBJECT\n            showText(\"GRABOBJECT: \" + str(_robot.objecttype))\n            \n    elif _robot.state == GRABOBJECT:\n        _dist_to_travel = move_robot(_robot)\n        if _dist_to_travel <= OBJECT_THRESHOLD+5:\n                                                      \n            _robot.gripper_close()\n            _proceed = False\n            # target reached, release route\n            if UseFleetmanager:\n                _robot.cmd = RELEASE_ROUTE\n                if DEBUG: serial.write_line(\"release route grabobject\")\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _proceed = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_route(_robot.location, _robot.destination)\n                _proceed = True\n            # update position\n            if _proceed:\n                _robot.location = _robot.destination\n                # switch to idle to start next route\n                _robot.state = IDLE\n                showText(\"IDLE\")\n        pass\n\n\n#---------------------------------------------------------------------------------------------------------\n# collision detection, can be based on camera or sensor on robot\n#---------------------------------------------------------------------------------------------------------\ndef collision_detected(_robot=Robot()):\n    #\n    # Needs implementing on robot\n    #\n    _robot.obstacle_detected = False\n    obstacle_detected = False\n    return obstacle_detected\n\n\n\n#---------------------------------------------------------------------------------------------------------\n#\n#  ROUTE HANDLING BELOW\n#\n#---------------------------------------------------------------------------------------------------------\n\n#---------------------------------------------------------------------------------------------------------\n# locations id's\n#---------------------------------------------------------------------------------------------------------\n\n# ids of waiting areas\nwaitingarea = [0]\nfor i in range(numwaitingareas):\n    waitingarea.append(i+1)\n# ids of storage areas\nstoragearea = [0]\nfor i in range(numwaitingareas, numwaitingareas+numstorage):\n    storagearea.append(i+1)\n# ids of target areas\ntarget = [0]\nfor i in range(numwaitingareas+numstorage, numwaitingareas+numstorage+numtargets):\n    target.append(i+1)\n# ids of objects\nobj = [0]\nfor i in range(numwaitingareas+numstorage+numtargets, numwaitingareas+numstorage+numtargets+numobjects):\n    obj.append(i+1)\n\n#occupation list of all locations\n#occupying = [0]  * (numlocations +1) -> does not work in Makecode\n# for compatibility reasons wit MakeCode on robot, do it like this\noccupying = [0]\nfor i in range(numlocations +1):\n    occupying.append(0)\n\nlocationnames = ['None']\nfor i in range(1,numwaitingareas+1):\n    locationnames.append(str('waitingarea ') + str(i))\nlocationnames.append(str('storage 1'))\nfor i in range(1,numobjects+1):\n    locationnames.append(str('targetarea ') + str(i))\nfor i in range(numobjects+1):\n    locationnames.append(str('object ') + str(i+1))\n\n#---------------------------------------------------------------------------------------------------------\n# instances of routes, using location id's\n#---------------------------------------------------------------------------------------------------------\nroutes = [(0,0)]\nfor i in range(50):\n    routes.append((0,0))\n\n# route automatic define from location, to location, use location numbers instead of coordinates for easier update\nfor i in range(numwaitingareas):\n    routes[i] = (waitingarea[1+i], storagearea[1])\noffset = numwaitingareas\nfor i in range(numobjects):\n    routes[i+offset] = (storagearea[1], target[1+i])\noffset += i+1\nfor i in range(numobjects):\n    if i < numobjects/2:\n        routes[i+offset] = (target[i+1], waitingarea[1])\n    else:\n        routes[i + offset] = (target[i+1], waitingarea[len(waitingarea)-1]) # waitingarea[-1] is not compatibel with Makecode\noffset += i+1\nidx = 0\nfor i in range(1, numwaitingareas):\n    if i < numwaitingareas/2:\n        routes[offset+i-1] = (waitingarea[i], waitingarea[i+1]) # shift from left to middle\n        idx = i\n    else:\n        routes[offset+i-1] = (waitingarea[len(waitingarea)-1]-i+idx+1, waitingarea[len(waitingarea)-1]-i+idx) # shift from right to middle\n\n\n# potentially crossing route combinations for additional clearance check\n# crossing routes:\n# - all routes from storage to targets in combination with all targets to waitingarea\n# - combination have to be all on left side or right side, right and left never cross (for now)\ncrossing_routes_ids = [((0,0),(0,0))]\ncrossing_routes = [(0,0)]\nfor i in range(len(routes)):\n    if routes[i][0] == storagearea[1]:\n        for j in range(len(routes)):\n            if routes[j][1] == waitingarea[1]:\n                if routes[j][0]<routes[i][1]:\n                    if routes[i][1] in target[1:int(numtargets/2)+1]:\n                        crossing_routes_ids.append((routes[i],routes[j]))\n                        crossing_routes.append((i, j))\n            if routes[j][1] == waitingarea[len(waitingarea)-1]:\n                if routes[j][0] < routes[i][1]:\n                    if routes[i][1] in target[int(numtargets/2)+1:numtargets+1]:\n                        crossing_routes_ids.append((routes[i], routes[j]))\n                        crossing_routes.append((i, j))\n\nactive_routes = [False]\nfor i in range(len(routes) +1):\n    active_routes.append(False)\ncrossed_routes = [False]\nfor i in range(len(routes) +1):\n    crossed_routes.append(False)\n\n\n#---------------------------------------------------------------------------------------------------------\n# check what next destination will be, this is the route scheduler, might be local or remote implemented\n#---------------------------------------------------------------------------------------------------------\ndef next_destination(_location, objecttype = None):\n    nxt_dest = _location # if there is no new location found, return current position as next destination\n    target_dir = AHEAD\n    # if we pick up an object, object nr tels us where to go\n    if (_location in storagearea) and (objecttype is not None):\n        # were need the collected object go to?\n        nxt_dest = target[objecttype]\n        # is target location left or rigth of us?\n        if nxt_dest in target[1:int(numtargets/2)+1]:\n            target_dir = LEFT\n        elif nxt_dest in target[int(numtargets/2)+1:numtargets+1]:\n            target_dir = RIGHT\n    # if we come from a target to the left, goto left most waiting area\n    elif _location in target[1:int(numtargets/2)+1]:\n        nxt_dest = waitingarea[1]\n        target_dir = LEFT\n    # if we come from a taget to the right, goto right most waiting area\n    elif _location in target[int(numtargets/2)+1:numtargets+1]:\n        nxt_dest = waitingarea[len(waitingarea)-1]\n        target_dir = RIGHT\n    # if we are in the waiting area, move toward the center wating area, before going back to the storage\n    elif _location in waitingarea:\n        # from waiting to storeage, unless we have to shift in the waiting area\n        nxt_dest = storagearea[1]\n        target_dir = LEFT\n        for i in range(1,int(numwaitingareas/2)+1):\n            # from left to middle\n            if _location == waitingarea[i]:\n                nxt_dest = waitingarea[i+1]\n                target_dir = LEFT\n            # from right to middle\n            if _location == waitingarea[len(waitingarea)-1]-i+1:\n                nxt_dest = waitingarea[len(waitingarea)-1]-i\n                target_dir = RIGHT\n    return nxt_dest, target_dir\n\n\n#---------------------------------------------------------------------------------------------------------\n# try to claim destination, if succesfull, returns True and own ID, if unsuccesfull returns ID that occupies the destination\n#---------------------------------------------------------------------------------------------------------\ndef claim_destination(_loc=0, _dest=0, _id=0):\n    claimed = 0\n    occupied = occupying[_dest]\n    if occupied == 0 and _id > 0:\n        occupying[_dest] = _id\n        claimed_id = _id\n        claimed = 1\n    else:\n        claimed_id = occupying[_dest]\n    if claimed_id == _id > 0:\n        if check_routes(_loc, _dest, _id):\n            occupying[_dest] = _id\n            #release_position(_loc) # this assumes that you start driving imediatly after claim of location\n        else:\n            claimed_id = 0\n    return claimed, claimed_id\n\n\n#---------------------------------------------------------------------------------------------------------\n# check if a destination is occupied, return ID that occupies destination\n#---------------------------------------------------------------------------------------------------------\ndef check_occupied(_dst):\n    claimed, occupied = claim_destination(_dest=_dst)\n    return occupied\n\n\n#---------------------------------------------------------------------------------------------------------\n# release location when you have left it\n#---------------------------------------------------------------------------------------------------------\ndef release_position(_location):\n    occupying[_location] = 0\n    return True\n\n\n#---------------------------------------------------------------------------------------------------------\n# release a route when we finished driving it\n#---------------------------------------------------------------------------------------------------------\ndef release_route(_loc,_dest):\n    _route = (_loc,_dest)\n    #if _route in [r for r in routes]: # not compatible with makecode\n    _found = False\n    for i in range(len(routes)):\n        if _route == routes[i]: _found = True\n    if _found:\n        # get route nr\n        _route_nr = routes.index(_route)\n        active_routes[_route_nr] = False\n    # check if route is actually released before returning -> need for remote implementation\n    while active_routes[_route_nr]:\n        # keep on trying to release the route\n        pass\n\n\n\n#---------------------------------------------------------------------------------------------------------\n# check if routes are crossing, claim route if crossing path is free\n#---------------------------------------------------------------------------------------------------------\ndef check_routes(_loc, _dest, _id):\n    if CollisionDetection: return True\n    proceed = True\n    # check start location of route\n    # is route valid and in route list]\n    _route = (_loc,_dest)\n    #if _route in [r for r in routes]: # not compatible with makecode\n    _found = False\n    for i in range(len(routes)):\n        if _route == routes[i] and routes[i] != (0, 0):\n            _found = True\n    if _found:\n        # get route nr\n        _route_nr = routes.index(_route)\n        #_r1 = _route_nr in [r[0] for r in crossing_routes]  # not compatible with makecode\n        #_r2 = _route_nr in [r[1] for r in crossing_routes] # not compatible with makecode\n        _r1 = False\n        _r2 = False\n        for i in range(1,len(crossing_routes)):\n            if _route_nr == crossing_routes[i][0]: _r1 = True\n            if _route_nr == crossing_routes[i][1]: _r2 = True\n        if _r1 or _r2:\n            proceed = False\n            for i in range(1,len(crossing_routes)):\n                if _route_nr == crossing_routes[i][0]:\n                    if not active_routes[crossing_routes[i][1]]:\n                        active_routes[_route_nr] = True\n                        crossed_routes[_route_nr] = False\n                        proceed = True\n                    else:\n                        crossed_routes[_route_nr] = True\n                if _route_nr == crossing_routes[i][1]:\n                    if not active_routes[crossing_routes[i][0]]:\n                        active_routes[_route_nr] = True\n                        crossed_routes[_route_nr] = False\n                        proceed = True\n                    else:\n                        crossed_routes[_route_nr] = True\n\n    return proceed\n\n\n\n#---------------------------------------------------------------------------------------------------------\n# buttons and switches\n#---------------------------------------------------------------------------------------------------------\n\ndef on_button_pressed_a():\n    global stopping, robot, DEBUG\n    stopping = False\n    robot.active = True\n    if DEBUG: serial.write_line('button pressed')\n    showText(\"ACTIVE\")\n    pass\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n\n'''\ndef on_button_pressed_b():\n    global stopping\n    stopping = True\n    if DEBUG: serial.write_line('reset')\n    pass\ninput.on_button_pressed(Button.B, on_button_pressed_b)\n'''\n\ndef leading_zeros(_num, _digits):\n    _str = '0'\n    _num = Math.round(_num)\n    if _num < 0: _num += 256\n    if _digits == 3:\n        if _num < 10 :\n            _str = '00' + str(_num)\n        elif _num < 100:\n            _str = '0' + str(_num)\n        elif _num < 1000:\n            _str = str(_num)\n    if _digits == 2:\n            if _num < 10 :\n                _str = '0' + str(_num)\n            elif _num < 100:\n                _str = str(_num)\n    return _str\n\nlatsprint = input.running_time()\n\ndef print_data():\n    global robot, DEBUG, latsprint\n    if DEBUG:\n        #serial.write_value(\"# \", control.device_serial_number())\n        t = input.running_time()\n        serial.write_value(\"t : \",t/1000)\n        serial.write_value(\"dt: \", (t-latsprint)/1000)\n        latsprint = t\n        serial.write_line(\"speed \"+robot.speed)\n        serial.write_line(\"yaw speed \"+robot.yaw_speed)\n        serial.write_line(\"distance target\"+robot.distance_to_target)\n        serial.write_value(\"state\", robot.state)\n        serial.write_line(state_names[robot.state])\n        serial.write_line(str(\"target \" ) + str(robot.target) + str(\"  \") + locationnames[robot.target])\n        serial.write_value(\"distance\", robot.distance_to_target)\n        serial.write_value(\"speed\", robot.speed)\n        _cmd = 0\n        _chk = (robot.id + _cmd + robot.state + robot.location + robot.destination + robot.target + robot.distance_to_target) % 8\n        _str = (leading_zeros(robot.id,2) + str(_cmd) + str(robot.state) +\n                    leading_zeros(robot.location,2) + leading_zeros(robot.destination,2)  + leading_zeros(robot.target,2) +\n                    leading_zeros(robot.distance_to_target,3) + leading_zeros(robot.speed,3) + str(_chk) + \"\\r\\n\")\n        serial.write_line(_str)\n        serial.write_line('--')\n    pass\n'''    \nloops.every_interval(500, print_data)\n'''\n\n'''\ndef on_serial_received():\n    global stopping, robot\n    data = serial.read_line()\n    if data == 'a':\n        stopping = False\n        robot.active = True\n        serial.write_line('remotley started')\n    if data == 'b':\n        stopping = True\n        serial.write_line('remotely reset')\n    pass\n    basic.pause(100) # yield for other processes\nserial.on_data_received(serial.delimiters(Delimiters.NEW_LINE), on_serial_received)\n'''\n\ndef on_radio_received(receivedString):\n    global robot, stopping, DEBUG, RadioTxPending, WaitingForReply\n    # cmd reply\n    # 0123456\n    # 1,1,1,1\n    # optimised without string split, and earlier reject of message\n    # radio_rx_data = receivedString\n    if receivedString[0] == str(robot.id):\n        #if DEBUG: serial.write_line(\"this is for us\")\n        if DEBUG: serial.write_line(\"rx:\" + receivedString)\n        #data = radio_rx_data.split(',')\n        #for d in range (len(data)):\n        #    if DEBUG: serial.write_line(data[d])\n        #_id = int(data[0])\n        #if _id == robot.id:\n        # this message is send for us\n        #_cmd = int(data[1])\n        _cmd = int(receivedString[2])\n        if _cmd == 0:\n            # send status report or pending command\n            #robot.cmd = STATUS_UPDATE\n            pass\n        elif _cmd == 1:\n            # NOK/OK claim destination reply\n            # data[2] = NOK/OK, data[3] = claimed id\n            #if int(data[3]) == robot.id:\n            if int(receivedString[6]) == robot.id:\n                robot.reply = OK\n                robot.cmd = 0 # no more commands\n            pass\n        elif _cmd == 2:\n            # ACK releaseposition\n            #if int(data[2]) == 2:\n            if int(receivedString[4]) == 2:\n                robot.reply = ACK\n                robot.cmd = 0\n            pass\n        elif _cmd == 3:\n            # ACK releaseroute\n            #if int(data[2]) == 2:\n            if int(receivedString[4]) == 2:\n                robot.reply = ACK\n                robot.cmd = 0\n            pass\n        elif _cmd == 4:\n            # START driving\n            stopping = False\n            robot.active = True\n            pass\n        elif _cmd == 5:\n            # STOP driving\n            stopping = True\n            robot.active = False\n            pass\n\n        RadioTxPending = False\n        WaitingForReply = False\n        #radio_transmit(robot)\n        #if DEBUG: serial.write_line(\"sending radio\")\n        yield_(5) # yield for other processes\n    pass\nradio.on_received_string(on_radio_received)\n\n\ndef radio_transmit(_robot=Robot()):\n    _cmd = _robot.cmd\n    _chk = (_robot.id + _cmd + _robot.state + _robot.location + _robot.destination + _robot.target + _robot.distance_to_target + _robot.speed) % 8\n    _str = (leading_zeros(robot.id,2) + str(_cmd) + str(robot.state) +\n                leading_zeros(robot.location,2) + leading_zeros(robot.destination,2)  + leading_zeros(robot.target,2) +\n                leading_zeros(robot.distance_to_target,3) + leading_zeros(robot.speed,3) + str(_chk) + \"\\r\\n\")\n    radio.send_string(_str)\n\n    #radio.send_string(\"id:\" + str(robot.id))\n    #radio.send_string(\",state:\" + str(robot.state))\n    #radio.send_string(str(\",loc:\" ) + str(robot.location))\n    #radio.send_string(str(\",des:\" ) + str(robot.destination))\n    #radio.send_string(str(\",tar:\" ) + str(robot.target))\n    #radio.send_string(\"\\r\\n\" )\n    #radio.send_string(str(\"target \" ) + str(robot.target) + str(\"  \") + locationnames[robot.target] + '\\r\\n')\n#loops.every_interval(250, on_every_interval)\n\ndef yield_(_t=50):\n    basic.pause(_t)\n\n\n#---------------------------------------------------------------------------------------------------------\n# actual main loop\n#---------------------------------------------------------------------------------------------------------\nstopping = False\nradio.set_group(1)\nclose_gripper()\n\nRadioTxTime = input.running_time()\nWaitingForReply = False \n\ndef on_forever():\n\n    global stopping, HIL_Simulation, robot, newdata, RadioTxPending, RadioTxTime, WaitingForReply\n    if not stopping:\n        if (robot.cmd == CLAIM_DESTINATION or robot.cmd == RELEASE_ROUTE) and not WaitingForReply:\n            if DEBUG: \n                if robot.cmd == CLAIM_DESTINATION: serial.write_line(\"radio tx claim destinatination\")\n                if robot.cmd == RELEASE_ROUTE: serial.write_line(\"radio tx release route\")\n            RadioTxPending = True\n        #if RadioTxPending and not WaitingForReply:\n            radio_transmit(robot) # send message\n            RadioTxPending =  False # we have send the message\n            RadioTxTime = input.running_time() # note send time\n            WaitingForReply = True # start waiting for reply\n        if WaitingForReply and (RadioTxTime - input.running_time()) > 1000: # timeout after 1 second\n            RadioTxPending = True # retry\n            WaitingForReply = False\n            RadioTxTime = input.running_time()\n            \n        if HIL_Simulation: \n            basic.pause(50)\n            newdata = True\n        if newdata:\n            newdata = False # sync to Huskylens\n            do_robot(robot)\n            print_data()\n\n    if HIL_Simulation: basic.pause(50)\n    #print_data() -> background loop\n    if stopping:\n        robot.active = False\n        robot.location = 1\n        robot.destination = 1\n        robot.target = 1\n        robot.objecttype = None\n        robot.state = IDLE\n    pass\n    yield_(5) # yield for other processes\n\nbasic.forever(on_forever)\n\n\n\ndef on_in_background():\n    #Huskylens\n    global t_start, t_last, dt_AI, inview, tagsInView, inview_count, x, y, w, h, newdata, zeroes\n    # approx 56 ms -> ~ 18 fps\n    t_start = input.running_time()\n    t_last = t_start\n    while 1:\n        \n        t_start = input.running_time()\n        dt_AI = t_start - t_last\n        # loop time\n        t_last = t_start\n        huskylens.request()\n        #yield_(20) # yield for other processes\n        inview = huskylens.get_box(HUSKYLENSResultType_t.HUSKYLENS_RESULT_BLOCK)\n        tagsInView = zeroes\n        k = 0\n        while k < inview:\n            tagsInView[k] = huskylens.readBox_ss(k + 1, Content3.ID)\n            k += 1\n        #serial.write_line(\"gripper : \"+str(robot.gripper))\n        if huskylens.is_appear(robot.target, HUSKYLENSResultType_t.HUSKYLENS_RESULT_BLOCK):\n            x = huskylens.reade_box(robot.target, Content1.X_CENTER)\n            y = huskylens.reade_box(robot.target, Content1.Y_CENTER)\n            w = huskylens.reade_box(robot.target, Content1.WIDTH)\n            h = huskylens.reade_box(robot.target, Content1.HEIGHT)\n            inview_count = 0\n        else:\n            inview_count += 1\n            if inview_count > 5: # if 3 frames no valid tag, reset to 0\n                x = -1\n                y = -1\n                w = -1\n                h = -1\n        newdata = True\n\n                          \ncontrol.in_background(on_in_background)","pxt.json":"{\n    \"name\": \"MPPS_demonstrator_python_only_v06\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"Huskylens\": \"github:dfrobot/pxt-dfrobot_huskylens#v2.0.6\",\n        \"maqueen\": \"github:dfrobot/pxt-maqueen#v1.7.5\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.51\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}},{"timestamp":1735233964409,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables></xml>","main.ts":"","README.md":"\n> Open this page at [https://artandtechvof.github.io/mpps_demonstrator_python_only_v02/](https://artandtechvof.github.io/mpps_demonstrator_python_only_v02/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/artandtechvof/mpps_demonstrator_python_only_v02** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/artandtechvof/mpps_demonstrator_python_only_v02** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n\n\n\n> Open this page at [https://artandtechvof.github.io/mpps_demonstrator_python_only_v05/](https://artandtechvof.github.io/mpps_demonstrator_python_only_v05/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/artandtechvof/mpps_demonstrator_python_only_v05** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/artandtechvof/mpps_demonstrator_python_only_v05** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","main.py":"CollisionDetection = False\nRandomDestination = True # random object or object based on own ID\nHIL_Simulation = True    # run code on \nFirstClaimDestination = True # True: wait for destination area te be cleared.\n                             # False: turn towards destination even if it is occupied\nUseFleetmanager = True\nID = 1\n\nDEBUG = True\n\nUseHusky = False\nDisplayDelay = 200\n\ndef showText(txt):\n    #if not HIL_Simulation:\n    if UseHusky:\n        txt = str(ID) + ' ' + txt\n        huskylens.clear_osd()\n        huskylens.write_osd(txt, 30, 30)\n        if HIL_Simulation: basic.pause(DisplayDelay)\n\n\n######################################\nserial.redirect_to_usb()\nserial.write_string(\"I am alive\")\nif not HIL_Simulation or UseHusky:\n    huskylens.init_i2c()\n    huskylens.init_mode(protocolAlgorithm.ALGORITHM_TAG_RECOGNITION)\n    showText(\"BOOTING\")\nbasic.pause(1000)\n######################################\n# number of robots\nnumrobots = 1\n# number of 'plastic' object types\nnumobjects = 4 # should be an even number for now\nnumtargets = numobjects\n# buffer zones for wating robots\n# 1 robot = 1 waiting\n# 2 robot = 1 waiting, 1 on storage location\n# 3 robot = 3 waiting, 1 left, 1 right 1 central\n# 4 robot = 5 waiting, 2 left, 2 right, 1 central\n# 5 robot = 7 waiting, 3 left, 3 right, 1 central\n# 6 robot = 9 waiting, 4 left, 4 right, 1 central\n# 7 robot = 11 waiting, 5 left, 5 right, 1 central\n# 8 robots = 13 waiting, 6 left, 6 right, 1 central\nif numrobots == 1:\n    numwaitingareas = 5 # adjust to demo\nelse:\n    numwaitingareas = max(3,(numrobots-1)*2 -1) # 1 central waiting area offset to the front\nnumstorage = 1 # try increasing this in future scenarios, attack waste-pile from multiple locations\n# total number of locations where robots can go\nnumlocations = numwaitingareas + numstorage + numtargets + numobjects\n\n\n# constants\nIDLE = 0\nDRIVEBACKWARD = 1\nFINDTARGET = 2\nGOTOTARGET = 3\nFINDOBJECT = 4\nGRABOBJECT = 5\n\nLOCATION_t = 0 # robot is looking for location\nOBJECT_t = 1   # robot is looking for object\n\nOPENED = 1\nCLOSED = 0\n\nAHEAD = 0\nLEFT  = 1\nRIGHT = 2\n\nMAXSPEED = 25\nMINSPEED = 15\nMINYAWSPEED = 8\nMAXYAWSPEED = 14\nBACKUPSPEED = -20\nBACKUPDISTANCE = 20\n\nOBJECT_THRESHOLD = 0 # minimum distance to object, before closing grippers\n\nstate_names = ['IDLE', 'DRIVEBACKWARD', 'FINDTARGET', 'GOTOTARGET', 'FINDOBJECT', 'GRABOBJECT']\ndirection_names = ['AHEAD', 'LEFT', 'RIGHT']\ncmd_names = ['STATUS_UPDATE','CLAIM_DESTINATION','RELEASE_POSITION','RELEASE_ROUTE','ROBOT_START','ROBOT_STOP']\nrply_names = ['NOK','OK','ACK']\n\n# commands\nSTATUS_UPDATE = 0\nCLAIM_DESTINATION = 1\nRELEASE_POSITION = 2\nRELEASE_ROUTE = 3\nROBOT_START = 4\nROBOT_STOP = 5\nNOK = 0\nOK = 1\nACK = 2\n\n#initialize variables related to huskylens\nt_start = 0\nt_last = 0\ndt_AI = 0\ninview = 0\nx = 0\ny = 0\nw = 0\nh = 0\nnewdata = False\ninview_count = 0\nRadioTxPending = False\n\ntagID = 1\n# tagIDs = [1 tm 6]\ntagSizes = [0,  85, 90, 90, 90, 85,  88,  88, 88, 88, 88,  55, 55, 55, 55] # 5x waiting, 1 central, 4 targets, 4 objects\n\ntagSize = tagSizes[tagID]\n\nzeroes = [0]\nwhile i < len(tagSizes):\n    zeroes.append(0)\n    i += 1\ntagsInView = zeroes\n#start_searching = 0\n\n\n#---------------------------------------------------------------------------------------------------------\n# helper function to open and close grippers, will be different on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef open_gripper():\n    opengripper = True\n    maqueen.servo_run(maqueen.Servos.S1, 85)\n    return opengripper\n\n\ndef close_gripper():\n    closegripper = True\n    maqueen.servo_run(maqueen.Servos.S1, 105)\n    return closegripper\n\ndef actuate_motors():\n    if HIL_Simulation: return True\n\n    left_speed = (robot.speed + robot.yaw_speed)\n    right_speed = (robot.speed + -robot.yaw_speed)\n    #serial.write_line(str(left_speed)+\" left speed\")\n    #serial.write_line(str(right_speed)+\" right speed\")\n    # set speed for motors here\n    if left_speed >=0:\n        maqueen.motor_run(maqueen.Motors.M1, maqueen.Dir.CW, left_speed)\n    else:\n        maqueen.motor_run(maqueen.Motors.M1, maqueen.Dir.CCW, -left_speed)\n    if right_speed >=0:\n       maqueen.motor_run(maqueen.Motors.M2, maqueen.Dir.CW, right_speed)\n    else:\n        maqueen.motor_run(maqueen.Motors.M2, maqueen.Dir.CCW, -right_speed)\n\n    return True\n\ndef get_time():\n    return input.running_time()\n\n#---------------------------------------------------------------------------------------------------------\n# base class of robot, can also be used on micro:Maqueen robot.\n# Robot() class, should be same for offline Simulation and actual physical demo robot\n#---------------------------------------------------------------------------------------------------------\nclass Robot:\n    def __init__(self, loc=1, dst=1, _id=1):\n        # who are we\n        self.id = _id\n        # ego location and destination nr\n        self.location = loc\n        self.destination = dst\n        self.target = dst\n        self.targettype = LOCATION_t\n        self.objecttype = None\n        # states\n        self.state = IDLE\n        self.gripper = CLOSED\n        self.speed = 0\n        self.yaw_speed = 0\n        # params\n        self.active = False\n        self.run_enable = False\n        self.steering_only = False # allowed to change heading but not driving\n        self.target_direction = AHEAD\n        self.target_inview = False  # target is in view of camera\n        self.target_locked = False # target is straight ahead\n        self.backup_distance = 0\n        self.distance_to_target = 0\n        self.backup_starttime = 0\n        self.looking_for_object = 0\n        self.route_length = 0\n        self.route_reported = False\n        self.obstacle_detected = False\n        self.cmd = 0\n        self.reply = 0\n\n    def gripper_open(self):\n        if open_gripper():\n            self.gripper = OPENED\n        pass\n\n    def gripper_close(self):\n        if close_gripper():\n            self.gripper = CLOSED\n        pass\n\n#---------------------------------------------------------------------------------------------------------\n# pre allocate robot instance as global\n#---------------------------------------------------------------------------------------------------------\nrobot = Robot( loc=ID, dst=ID, _id=ID)\n\n\n#---------------------------------------------------------------------------------------------------------\n# this function will be based on camera on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef calc_heading(_robot=Robot()):\n\n    #angle error in pixels\n    # x = position of tag in camera view, 320 wide, 160 is center\n    if HIL_Simulation:\n        basic.pause(100)\n        return 0\n        \n    angle_err = 160-x\n    \n    return angle_err\n\n\n#---------------------------------------------------------------------------------------------------------\n# this function will be based on camera on actual robot\n#---------------------------------------------------------------------------------------------------------\ndef calc_distance(_robot=Robot()):\n    '''\n    if not _robot.state == DRIVEBACKWARD:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.dest[0]))**2 + ((_robot.position[1] - _robot.dest[1]))**2)\n    else:\n        dist_err = Math.sqrt(((_robot.position[0] - _robot.startposition[0]))**2 + ((_robot.position[1] - _robot.startposition[1]))**2)\n    '''\n    tagSize = tagSizes[_robot.target]\n    tagID = _robot.target\n    \n    if HIL_Simulation:\n        if not _robot.state == DRIVEBACKWARD:\n            distance_measured = _robot.distance_to_target - _robot.speed # drive towards target\n        else:\n            distance_measured = _robot.distance_to_target + abs(_robot.speed) # drive away from target\n    else :\n        distance_measured = tagSize - h  # height of tag - height of tag measured\n        #serial.write_line('h='+h+'tagsize:'+tagSize) # soort timeout invoeren\n    \n    distance_measured = max(distance_measured,0) # distance cannot be negative\n\n    return distance_measured\n    \n\n#---------------------------------------------------------------------------------------------------------\n# look for target and aim robot towards it, different in offline Simulation vs actual robot\n#---------------------------------------------------------------------------------------------------------\ndef find_target(_robot=Robot()):\n    # We are driving towards a location\n    if _robot.targettype == LOCATION_t:\n        _robot.target = _robot.destination\n    # We are looking for and driving to an object\n    if _robot.targettype == OBJECT_t:\n        # start looking for the object\n        _robot.target = obj[_robot.objecttype] # obj location nr will become new target\n\n    _robot.steering_only = True\n    # set preffered turning direction?\n    # actuate drive and steering\n\n    _dist = move_robot(_robot)\n    return _dist\n\n#---------------------------------------------------------------------------------------------------------\n#function to search target\n#---------------------------------------------------------------------------------------------------------\ndef pulse(_dir=LEFT,_robot=Robot()):\n    #pulsing behaviour\n    pulse_duration = 700  # Duration of one complete pulse cycle\n    active_ratio = 0.2  # Ratio of time the robot is actively turning within a pulse\n    base_speed = 15\n    speed_multiplier = 1.5\n\n    if robot.state == FINDOBJECT:\n        speed_multiplier = 1.5\n        if robot.looking_for_object == 0:\n            _robot.looking_for_object = input.running_time()\n        else:\n            time_looking = input.running_time() - _robot.looking_for_object\n            if time_looking < 2000:\n                 _dir = LEFT\n            else: _dir = RIGHT\n\n\n\n\n    #if start_searching == 0: # als\n    #    start_searching = input.running_time()\n    \n    #calculate searching time\n    #searching_time = input.running_time() - start_searching\n    # Calculate the phase of the pulse (0 to 1)\n    pulse_phase = (input.running_time() % pulse_duration) / pulse_duration\n\n    #calculate if we are in the active part of the pulse\n    is_active_pulse = pulse_phase < active_ratio\n\n    if is_active_pulse:\n        # During active pulse: turn with increased speed\n        turn_speed = base_speed * speed_multiplier\n    else:\n        # During inactive pulse: stand still\n        turn_speed = base_speed\n\n    if _dir == LEFT: turn_speed = -turn_speed\n\n    return turn_speed\n\n\n    #if payload:\n    #    speed_left *= 1.15\n    #    speed_right *= 1.15\n\n#---------------------------------------------------------------------------------------------------------\n# actual motion control, aim for target, with or without speed\n#---------------------------------------------------------------------------------------------------------\ndef move_robot(_robot=Robot()):\n\n    #check if robot is allowed to move\n    dist_err = 999 # default distance error\n    if not _robot.run_enable:\n            _robot.speed = 0\n            _robot.yaw_speed = 0\n\n    #check if target is in sight\n    if (_robot.target in tagsInView) or HIL_Simulation:\n            _robot.target_inview = True\n                                              \n                                                      \n\n    else:\n        # add timeout before target is no longer in view???\n        _robot.target_inview = False\n        _robot.target_locked = False\n\n    #if target is not in view turn around to look for target, use pulsed turning to speed up process\n    if not _robot.target_inview:\n        _robot.speed = 0\n        _robot.yaw_speed = pulse(_robot.target_direction,_robot)\n    # if target is in view\n    else:\n        # heading / steering control\n        angle_err = calc_heading(_robot) # how many pixels are we off centre\n        dist_err = calc_distance(_robot) # how many pixels are we away from target\n        _robot.distance_to_target = dist_err # store on instance of robot, for logistical and rouet handling\n\n        # heading control, simple P-control\n        Kp = 1.0\n        _robot.yaw_speed = -angle_err * Kp # simple P-control of heading angle\n        if _robot.target_locked:\n            _robot.yaw_speed = max(-MAXYAWSPEED, min(_robot.yaw_speed, MAXYAWSPEED))\n        else:\n            _robot.yaw_speed = max(-MAXYAWSPEED, min(_robot.yaw_speed, MAXYAWSPEED))\n\n        # speed control, start driving when target is almost straight ahead of robot\n        if abs(angle_err) < 10:\n            _robot.yaw_speed = 0\n            _robot.target_locked = True\n            # speed control, simple P-control\n            Kp = 2.0\n            _robot.speed = min(dist_err * Kp, MAXSPEED)\n            # drive slow when approaching an object\n            if _robot.state == GRABOBJECT: _robot.speed = min(MINSPEED, _robot.speed * Kp)\n            \n        else:\n            _robot.target_locked = False\n\n        # steering only when aiming for target\n        if _robot.steering_only:\n            _robot.speed = 0\n\n        # if obstacle detected stop robot\n        if CollisionDetection and collision_detected(_robot):\n            _robot.speed = 0\n            _robot.yaw_speed = 0\n\n        # adjust turning speed depening on driving or turning when standing still\n        if _robot.speed > 0 :\n            # while driving reduce maximum turning speed, for smoother driving\n            _robot.yaw_speed = max(-MINYAWSPEED/4, min(_robot.yaw_speed, MINYAWSPEED/4))\n\n        else:\n            # turn while standing still, use minimum turning speed\n            if  _robot.yaw_speed > 0:\n                if _robot.yaw_speed < MAXYAWSPEED: _robot.yaw_speed = MAXYAWSPEED\n            if  _robot.yaw_speed < 0:\n                if _robot.yaw_speed > -MAXYAWSPEED: _robot.yaw_speed = -MAXYAWSPEED\n\n    actuate_motors()\n    return dist_err\n\n\n#---------------------------------------------------------------------------------------------------------\n# actively stop robot\n#---------------------------------------------------------------------------------------------------------\ndef stop_robot(_robot=Robot()):\n    _robot.speed = 0\n    _robot.yaw_speed = 0\n    actuate_motors()\n\n#---------------------------------------------------------------------------------------------------------\n# drive backward to clear storage or target areas\n#---------------------------------------------------------------------------------------------------------\ndef reverse_robot(_robot=Robot()):\n    dist_err = calc_distance(_robot)\n    # drive straight backward, without steering\n    _robot.yaw_speed = 0\n    # have we driven far enough backward? distance is trigger, could also be timed reverse driving\n    if (input.running_time() - _robot.backup_starttime) < 750: # 0.75 seconds\n        _robot.looking_for_object = 0\n    #if dist_err < _robot.backup_distance:\n        _robot.speed = BACKUPSPEED\n        _finished = False\n    else:\n        _finished = True\n        _robot.speed = 0\n    actuate_motors()\n    return _finished\n\n\n#---------------------------------------------------------------------------------------------------------\n# run robot main code (similar to real-time implementation)\n#---------------------------------------------------------------------------------------------------------\ndef do_robot(_robot=Robot()):\n    # statemachine\n    if _robot.state == IDLE:\n        _robot.run_enable = False\n        _robot.speed = 0\n        _robot.yaw_speed = 0\n        _robot.cmd = STATUS_UPDATE\n        stop_robot(_robot)\n        if _robot.active:\n            # we are allowed to drive\n            _robot.run_enable = True\n            # request next destination, if we cary an object we are going to an output stream area\n            result = next_destination( _robot.destination, _robot.objecttype)\n            _robot.destination = result[0]\n            _robot.target_direction = result[1]\n            _robot.target = _robot.destination\n            # if we are in the waiting area, we do not need to back up, otherwise, backup before driving\n            if HIL_Simulation:\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n            # maybe  try to claim the location here. With QR code another robot might be in the way of seeing the QR code\n            # when the robot has reased its starting position (claim released) the QR code should be visible\n            if _robot.location in waitingarea:\n                _robot.backup_distance = 0\n                _robot.state = FINDTARGET  # directly start aiming for next destination\n                #serial.write_line(\"state find target\")\n                showText(\"FINDTARGET: \" + str(_robot.target) + ' ' + direction_names[_robot.target_direction])\n                # for HIL_Simulation only\n                if HIL_Simulation:\n                    _robot.distance_to_target = 90\n                    _robot.route_length = _robot.distance_to_target\n\n            else:\n                # backup distance\n                _robot.backup_distance = BACKUPDISTANCE\n                #serial.write_line(\"state drive backwards\")\n                showText(\"DRIVEBACKWARD\")\n                _robot.state = DRIVEBACKWARD  # drive backwards first\n                _robot.backup_starttime = get_time() # input.running_time()\n                # if wa are at target area, weh open gripper and drive backward to leave object there\n                if _robot.location in target[1:numtargets+1]:\n                    _robot.gripper_open()\n                    _robot.objecttype = None # we leave the object here\n                    pass\n                #elif _robot.location in storagearea:\n                # randomly assign new object to location where last object was taken from\n                #    nxt_object = randint(1, numobjects+1)\n                #    waste_object[_robot.objecttype].color = colorlist[nxt_object]  # we leave the object here\n                #    waste_object[_robot.objecttype].objecttype = nxt_object\n                #    pass\n                else:\n                    # all other areas we drive backward with grippers closed\n                    _robot.gripper_close()\n                    pass\n                # for HIL_Simulation only\n                if HIL_Simulation: _robot.distance_to_target = 0\n        pass\n    elif _robot.state == DRIVEBACKWARD:\n        # drive backwards\n        if reverse_robot(_robot):\n            _robot.state = FINDTARGET\n            showText(\"FINDTARGET: \" + str(_robot.target) + ' ' + direction_names[_robot.target_direction])\n            _robot.gripper_close()\n            # for HIL_Simulation only\n            if HIL_Simulation:\n                _robot.distance_to_target = 90\n                _robot.route_length = _robot.distance_to_target\n        pass\n    elif _robot.state == FINDTARGET:\n        # find target by rotating robot, but do not drive\n        _proceed = False\n        if FirstClaimDestination:\n             if UseFleetmanager:\n                 _robot.cmd = CLAIM_DESTINATION\n                 if _robot.reply == OK:\n                     _robot.reply = 0 # reset for next command\n                     _proceed = True\n                     _robot.cmd = STATUS_UPDATE\n                 pass\n             else:\n                if claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                    _proceed = True\n        else:\n            _proceed = True\n\n        if _proceed:\n            _robot.targettype = LOCATION_t\n            _dist_to_travel = find_target(_robot)\n            # when we have found the target, we are going to drive towards it\n            if _robot.target_locked:\n                # we have found the target, re-check if it is clear to drive there\n                #if CollisionDetection or claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                if not FirstClaimDestination:\n                    _proceed = False\n                    if CollisionDetection:\n                        _proceed = True\n                    elif UseFleetmanager:\n                        _robot.cmd = CLAIM_DESTINATION\n                        if _robot.reply == OK:\n                            _robot.reply = 0 # reset for next command\n                            _proceed = True\n                            _robot.cmd = STATUS_UPDATE\n                        pass\n                    elif claim_destination(_robot.location, _robot.destination, _robot.id)[1] == _robot.id:\n                            _proceed = True\n                if _proceed:\n                    showText(\"GOTOTARGET: \" + str(_robot.target))\n                    _robot.state = GOTOTARGET\n                    _robot.route_reported = False\n                    _robot.route_length = _dist_to_travel\n                    _robot.cmd = STATUS_UPDATE\n        pass\n    elif _robot.state == GOTOTARGET:\n        # make sure we keep claim on target area\n        _robot.steering_only = False\n        _dist_to_travel = move_robot(_robot)\n        _proceed = False\n        _robot.cmd = STATUS_UPDATE\n        # report route haflway, only onetime reporting\n        if _dist_to_travel < _robot.route_length/2 and not _robot.route_reported:\n            if UseFleetmanager:\n                _robot.route_reported = True\n                pass # do not report release position\n                '''\n                _robot.cmd = RELEASE_POSITION\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _robot.route_reported = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n                '''\n            else:\n                release_position(_robot.location)\n                _robot.route_reported = True\n        _robot.distance_to_target = _dist_to_travel\n        # if we approach storage, open gripper before reaching destination\n        if _robot.destination in storagearea:\n            if _dist_to_travel == 0:\n                _robot.state = FINDOBJECT\n                # assign an object to look for\n                if RandomDestination:\n                    _robot.objecttype = randint(1, numobjects) # a random object is assigned to robot\n                else:\n                    _robot.objecttype = _robot.id  # robot ID determines object types to be retrieved\n                # switch state and start looking for object\n                showText(\"FINDOBJECT: \" + str(_robot.objecttype))\n                pass\n        elif _dist_to_travel <= 0+5:\n            # target reached, release route\n            _proceed = False\n            if UseFleetmanager:\n                _robot.cmd = RELEASE_ROUTE\n                if DEBUG: serial.write_line(\"release route gototarget\")\n                if DEBUG: serial.write_line(\"reply: \" + str(_robot.reply))\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _proceed = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_route(_robot.location, _robot.destination)\n                _proceed = True\n            # update position\n            if _proceed:\n                _robot.location = _robot.destination\n                _robot.state = IDLE\n                _robot.cmd = STATUS_UPDATE\n                showText(\"IDLE\")\n        pass\n    elif _robot.state == FINDOBJECT:\n        # Finding object could be done by sweeping left and reight until object is found\n        _robot.steering_only = True\n        # if we approcah storage, open gripper before reaching destination\n        _robot.targettype = OBJECT_t\n        find_target(_robot)\n        if _robot.target_locked:\n            _robot.steering_only = False\n                                                     \n            _robot.gripper_open()\n            _robot.state = GRABOBJECT\n            showText(\"GRABOBJECT: \" + str(_robot.objecttype))\n            \n    elif _robot.state == GRABOBJECT:\n        _dist_to_travel = move_robot(_robot)\n        if _dist_to_travel <= OBJECT_THRESHOLD+5:\n                                                      \n            _robot.gripper_close()\n            _proceed = False\n            # target reached, release route\n            if UseFleetmanager:\n                _robot.cmd = RELEASE_ROUTE\n                if DEBUG: serial.write_line(\"release route grabobject\")\n                if _robot.reply == ACK:\n                    _robot.reply = 0 # reset for next command\n                    _proceed = True\n                    _robot.cmd = STATUS_UPDATE\n                pass\n            else:\n                release_route(_robot.location, _robot.destination)\n                _proceed = True\n            # update position\n            if _proceed:\n                _robot.location = _robot.destination\n                # switch to idle to start next route\n                _robot.state = IDLE\n                showText(\"IDLE\")\n        pass\n\n\n#---------------------------------------------------------------------------------------------------------\n# collision detection, can be based on camera or sensor on robot\n#---------------------------------------------------------------------------------------------------------\ndef collision_detected(_robot=Robot()):\n    #\n    # Needs implementing on robot\n    #\n    _robot.obstacle_detected = False\n    obstacle_detected = False\n    return obstacle_detected\n\n\n\n#---------------------------------------------------------------------------------------------------------\n#\n#  ROUTE HANDLING BELOW\n#\n#---------------------------------------------------------------------------------------------------------\n\n#---------------------------------------------------------------------------------------------------------\n# locations id's\n#---------------------------------------------------------------------------------------------------------\n\n# ids of waiting areas\nwaitingarea = [0]\nfor i in range(numwaitingareas):\n    waitingarea.append(i+1)\n# ids of storage areas\nstoragearea = [0]\nfor i in range(numwaitingareas, numwaitingareas+numstorage):\n    storagearea.append(i+1)\n# ids of target areas\ntarget = [0]\nfor i in range(numwaitingareas+numstorage, numwaitingareas+numstorage+numtargets):\n    target.append(i+1)\n# ids of objects\nobj = [0]\nfor i in range(numwaitingareas+numstorage+numtargets, numwaitingareas+numstorage+numtargets+numobjects):\n    obj.append(i+1)\n\n#occupation list of all locations\n#occupying = [0]  * (numlocations +1) -> does not work in Makecode\n# for compatibility reasons wit MakeCode on robot, do it like this\noccupying = [0]\nfor i in range(numlocations +1):\n    occupying.append(0)\n\nlocationnames = ['None']\nfor i in range(1,numwaitingareas+1):\n    locationnames.append(str('waitingarea ') + str(i))\nlocationnames.append(str('storage 1'))\nfor i in range(1,numobjects+1):\n    locationnames.append(str('targetarea ') + str(i))\nfor i in range(numobjects+1):\n    locationnames.append(str('object ') + str(i+1))\n\n#---------------------------------------------------------------------------------------------------------\n# instances of routes, using location id's\n#---------------------------------------------------------------------------------------------------------\nroutes = [(0,0)]\nfor i in range(50):\n    routes.append((0,0))\n\n# route automatic define from location, to location, use location numbers instead of coordinates for easier update\nfor i in range(numwaitingareas):\n    routes[i] = (waitingarea[1+i], storagearea[1])\noffset = numwaitingareas\nfor i in range(numobjects):\n    routes[i+offset] = (storagearea[1], target[1+i])\noffset += i+1\nfor i in range(numobjects):\n    if i < numobjects/2:\n        routes[i+offset] = (target[i+1], waitingarea[1])\n    else:\n        routes[i + offset] = (target[i+1], waitingarea[len(waitingarea)-1]) # waitingarea[-1] is not compatibel with Makecode\noffset += i+1\nidx = 0\nfor i in range(1, numwaitingareas):\n    if i < numwaitingareas/2:\n        routes[offset+i-1] = (waitingarea[i], waitingarea[i+1]) # shift from left to middle\n        idx = i\n    else:\n        routes[offset+i-1] = (waitingarea[len(waitingarea)-1]-i+idx+1, waitingarea[len(waitingarea)-1]-i+idx) # shift from right to middle\n\n\n# potentially crossing route combinations for additional clearance check\n# crossing routes:\n# - all routes from storage to targets in combination with all targets to waitingarea\n# - combination have to be all on left side or right side, right and left never cross (for now)\ncrossing_routes_ids = [((0,0),(0,0))]\ncrossing_routes = [(0,0)]\nfor i in range(len(routes)):\n    if routes[i][0] == storagearea[1]:\n        for j in range(len(routes)):\n            if routes[j][1] == waitingarea[1]:\n                if routes[j][0]<routes[i][1]:\n                    if routes[i][1] in target[1:int(numtargets/2)+1]:\n                        crossing_routes_ids.append((routes[i],routes[j]))\n                        crossing_routes.append((i, j))\n            if routes[j][1] == waitingarea[len(waitingarea)-1]:\n                if routes[j][0] < routes[i][1]:\n                    if routes[i][1] in target[int(numtargets/2)+1:numtargets+1]:\n                        crossing_routes_ids.append((routes[i], routes[j]))\n                        crossing_routes.append((i, j))\n\nactive_routes = [False]\nfor i in range(len(routes) +1):\n    active_routes.append(False)\ncrossed_routes = [False]\nfor i in range(len(routes) +1):\n    crossed_routes.append(False)\n\n\n#---------------------------------------------------------------------------------------------------------\n# check what next destination will be, this is the route scheduler, might be local or remote implemented\n#---------------------------------------------------------------------------------------------------------\ndef next_destination(_location, objecttype = None):\n    nxt_dest = _location # if there is no new location found, return current position as next destination\n    target_dir = AHEAD\n    # if we pick up an object, object nr tels us where to go\n    if (_location in storagearea) and (objecttype is not None):\n        # were need the collected object go to?\n        nxt_dest = target[objecttype]\n        # is target location left or rigth of us?\n        if nxt_dest in target[1:int(numtargets/2)+1]:\n            target_dir = LEFT\n        elif nxt_dest in target[int(numtargets/2)+1:numtargets+1]:\n            target_dir = RIGHT\n    # if we come from a target to the left, goto left most waiting area\n    elif _location in target[1:int(numtargets/2)+1]:\n        nxt_dest = waitingarea[1]\n        target_dir = LEFT\n    # if we come from a taget to the right, goto right most waiting area\n    elif _location in target[int(numtargets/2)+1:numtargets+1]:\n        nxt_dest = waitingarea[len(waitingarea)-1]\n        target_dir = RIGHT\n    # if we are in the waiting area, move toward the center wating area, before going back to the storage\n    elif _location in waitingarea:\n        # from waiting to storeage, unless we have to shift in the waiting area\n        nxt_dest = storagearea[1]\n        target_dir = LEFT\n        for i in range(1,int(numwaitingareas/2)+1):\n            # from left to middle\n            if _location == waitingarea[i]:\n                nxt_dest = waitingarea[i+1]\n                target_dir = LEFT\n            # from right to middle\n            if _location == waitingarea[len(waitingarea)-1]-i+1:\n                nxt_dest = waitingarea[len(waitingarea)-1]-i\n                target_dir = RIGHT\n    return nxt_dest, target_dir\n\n\n#---------------------------------------------------------------------------------------------------------\n# try to claim destination, if succesfull, returns True and own ID, if unsuccesfull returns ID that occupies the destination\n#---------------------------------------------------------------------------------------------------------\ndef claim_destination(_loc=0, _dest=0, _id=0):\n    claimed = 0\n    occupied = occupying[_dest]\n    if occupied == 0 and _id > 0:\n        occupying[_dest] = _id\n        claimed_id = _id\n        claimed = 1\n    else:\n        claimed_id = occupying[_dest]\n    if claimed_id == _id > 0:\n        if check_routes(_loc, _dest, _id):\n            occupying[_dest] = _id\n            #release_position(_loc) # this assumes that you start driving imediatly after claim of location\n        else:\n            claimed_id = 0\n    return claimed, claimed_id\n\n\n#---------------------------------------------------------------------------------------------------------\n# check if a destination is occupied, return ID that occupies destination\n#---------------------------------------------------------------------------------------------------------\ndef check_occupied(_dst):\n    claimed, occupied = claim_destination(_dest=_dst)\n    return occupied\n\n\n#---------------------------------------------------------------------------------------------------------\n# release location when you have left it\n#---------------------------------------------------------------------------------------------------------\ndef release_position(_location):\n    occupying[_location] = 0\n    return True\n\n\n#---------------------------------------------------------------------------------------------------------\n# release a route when we finished driving it\n#---------------------------------------------------------------------------------------------------------\ndef release_route(_loc,_dest):\n    _route = (_loc,_dest)\n    #if _route in [r for r in routes]: # not compatible with makecode\n    _found = False\n    for i in range(len(routes)):\n        if _route == routes[i]: _found = True\n    if _found:\n        # get route nr\n        _route_nr = routes.index(_route)\n        active_routes[_route_nr] = False\n    # check if route is actually released before returning -> need for remote implementation\n    while active_routes[_route_nr]:\n        # keep on trying to release the route\n        pass\n\n\n\n#---------------------------------------------------------------------------------------------------------\n# check if routes are crossing, claim route if crossing path is free\n#---------------------------------------------------------------------------------------------------------\ndef check_routes(_loc, _dest, _id):\n    if CollisionDetection: return True\n    proceed = True\n    # check start location of route\n    # is route valid and in route list]\n    _route = (_loc,_dest)\n    #if _route in [r for r in routes]: # not compatible with makecode\n    _found = False\n    for i in range(len(routes)):\n        if _route == routes[i] and routes[i] != (0, 0):\n            _found = True\n    if _found:\n        # get route nr\n        _route_nr = routes.index(_route)\n        #_r1 = _route_nr in [r[0] for r in crossing_routes]  # not compatible with makecode\n        #_r2 = _route_nr in [r[1] for r in crossing_routes] # not compatible with makecode\n        _r1 = False\n        _r2 = False\n        for i in range(1,len(crossing_routes)):\n            if _route_nr == crossing_routes[i][0]: _r1 = True\n            if _route_nr == crossing_routes[i][1]: _r2 = True\n        if _r1 or _r2:\n            proceed = False\n            for i in range(1,len(crossing_routes)):\n                if _route_nr == crossing_routes[i][0]:\n                    if not active_routes[crossing_routes[i][1]]:\n                        active_routes[_route_nr] = True\n                        crossed_routes[_route_nr] = False\n                        proceed = True\n                    else:\n                        crossed_routes[_route_nr] = True\n                if _route_nr == crossing_routes[i][1]:\n                    if not active_routes[crossing_routes[i][0]]:\n                        active_routes[_route_nr] = True\n                        crossed_routes[_route_nr] = False\n                        proceed = True\n                    else:\n                        crossed_routes[_route_nr] = True\n\n    return proceed\n\n\n\n#---------------------------------------------------------------------------------------------------------\n# buttons and switches\n#---------------------------------------------------------------------------------------------------------\n\ndef on_button_pressed_a():\n    global stopping, robot, DEBUG\n    stopping = False\n    robot.active = True\n    if DEBUG: serial.write_line('button pressed')\n    showText(\"ACTIVE\")\n    pass\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n\n'''\ndef on_button_pressed_b():\n    global stopping\n    stopping = True\n    if DEBUG: serial.write_line('reset')\n    pass\ninput.on_button_pressed(Button.B, on_button_pressed_b)\n'''\n\ndef leading_zeros(_num, _digits):\n    _str = '0'\n    _num = Math.round(_num)\n    if _num < 0: _num += 256\n    if _digits == 3:\n        if _num < 10 :\n            _str = '00' + str(_num)\n        elif _num < 100:\n            _str = '0' + str(_num)\n        elif _num < 1000:\n            _str = str(_num)\n    if _digits == 2:\n            if _num < 10 :\n                _str = '0' + str(_num)\n            elif _num < 100:\n                _str = str(_num)\n    return _str\n\nlatsprint = input.running_time()\n\ndef print_data():\n    global robot, DEBUG, latsprint\n    if DEBUG:\n        #serial.write_value(\"# \", control.device_serial_number())\n        t = input.running_time()\n        serial.write_value(\"t : \",t/1000)\n        serial.write_value(\"dt: \", (t-latsprint)/1000)\n        latsprint = t\n        serial.write_line(\"speed \"+robot.speed)\n        serial.write_line(\"yaw speed \"+robot.yaw_speed)\n        serial.write_line(\"distance target\"+robot.distance_to_target)\n        serial.write_value(\"state\", robot.state)\n        serial.write_line(state_names[robot.state])\n        serial.write_line(str(\"target \" ) + str(robot.target) + str(\"  \") + locationnames[robot.target])\n        serial.write_value(\"distance\", robot.distance_to_target)\n        serial.write_value(\"speed\", robot.speed)\n        _cmd = 0\n        _chk = (robot.id + _cmd + robot.state + robot.location + robot.destination + robot.target + robot.distance_to_target) % 8\n        _str = (leading_zeros(robot.id,2) + str(_cmd) + str(robot.state) +\n                    leading_zeros(robot.location,2) + leading_zeros(robot.destination,2)  + leading_zeros(robot.target,2) +\n                    leading_zeros(robot.distance_to_target,3) + leading_zeros(robot.speed,3) + str(_chk) + \"\\r\\n\")\n        serial.write_line(_str)\n        serial.write_line('--')\n    pass\n'''    \nloops.every_interval(500, print_data)\n'''\n\n'''\ndef on_serial_received():\n    global stopping, robot\n    data = serial.read_line()\n    if data == 'a':\n        stopping = False\n        robot.active = True\n        serial.write_line('remotley started')\n    if data == 'b':\n        stopping = True\n        serial.write_line('remotely reset')\n    pass\n    basic.pause(100) # yield for other processes\nserial.on_data_received(serial.delimiters(Delimiters.NEW_LINE), on_serial_received)\n'''\n\ndef on_radio_received(receivedString):\n    global robot, stopping, DEBUG, RadioTxPending, WaitingForReply\n    # cmd reply\n    # 0123456\n    # 1,1,1,1\n    # optimised without string split, and earlier reject of message\n    # radio_rx_data = receivedString\n    if receivedString[0] == str(robot.id):\n        #if DEBUG: serial.write_line(\"this is for us\")\n        if DEBUG: serial.write_line(\"rx:\" + receivedString)\n        #data = radio_rx_data.split(',')\n        #for d in range (len(data)):\n        #    if DEBUG: serial.write_line(data[d])\n        #_id = int(data[0])\n        #if _id == robot.id:\n        # this message is send for us\n        #_cmd = int(data[1])\n        _cmd = int(receivedString[2])\n        if _cmd == 0:\n            # send status report or pending command\n            #robot.cmd = STATUS_UPDATE\n            pass\n        elif _cmd == 1:\n            # NOK/OK claim destination reply\n            # data[2] = NOK/OK, data[3] = claimed id\n            #if int(data[3]) == robot.id:\n            if int(receivedString[6]) == robot.id:\n                robot.reply = OK\n                robot.cmd = 0 # no more commands\n            pass\n        elif _cmd == 2:\n            # ACK releaseposition\n            #if int(data[2]) == 2:\n            if int(receivedString[4]) == 2:\n                robot.reply = ACK\n                robot.cmd = 0\n            pass\n        elif _cmd == 3:\n            # ACK releaseroute\n            #if int(data[2]) == 2:\n            if int(receivedString[4]) == 2:\n                robot.reply = ACK\n                robot.cmd = 0\n            pass\n        elif _cmd == 4:\n            # START driving\n            stopping = False\n            robot.active = True\n            pass\n        elif _cmd == 5:\n            # STOP driving\n            stopping = True\n            robot.active = False\n            pass\n\n        if DEBUG: serial.write_line(\"reply: \" + str(robot.reply))\n        RadioTxPending = False\n        WaitingForReply = False\n        #radio_transmit(robot)\n        #if DEBUG: serial.write_line(\"sending radio\")\n        yield_(5) # yield for other processes\n    pass\nradio.on_received_string(on_radio_received)\n\n\ndef radio_transmit(_robot=Robot()):\n    _cmd = _robot.cmd\n    _chk = (_robot.id + _cmd + _robot.state + _robot.location + _robot.destination + _robot.target + _robot.distance_to_target + _robot.speed) % 8\n    _str = (leading_zeros(robot.id,2) + str(_cmd) + str(robot.state) +\n                leading_zeros(robot.location,2) + leading_zeros(robot.destination,2)  + leading_zeros(robot.target,2) +\n                leading_zeros(robot.distance_to_target,3) + leading_zeros(robot.speed,3) + str(_chk) + \"\\r\\n\")\n    radio.send_string(_str)\n\n    #radio.send_string(\"id:\" + str(robot.id))\n    #radio.send_string(\",state:\" + str(robot.state))\n    #radio.send_string(str(\",loc:\" ) + str(robot.location))\n    #radio.send_string(str(\",des:\" ) + str(robot.destination))\n    #radio.send_string(str(\",tar:\" ) + str(robot.target))\n    #radio.send_string(\"\\r\\n\" )\n    #radio.send_string(str(\"target \" ) + str(robot.target) + str(\"  \") + locationnames[robot.target] + '\\r\\n')\n#loops.every_interval(250, on_every_interval)\n\ndef yield_(_t=50):\n    basic.pause(_t)\n\n\n#---------------------------------------------------------------------------------------------------------\n# actual main loop\n#---------------------------------------------------------------------------------------------------------\nstopping = False\nradio.set_group(1)\nclose_gripper()\n\nRadioTxTime = input.running_time()\nWaitingForReply = False \n\ndef on_forever():\n\n    global stopping, HIL_Simulation, robot, newdata, RadioTxPending, RadioTxTime, WaitingForReply\n    if not stopping:\n        if (robot.cmd == CLAIM_DESTINATION or robot.cmd == RELEASE_ROUTE) and not WaitingForReply:\n            if DEBUG: \n                if robot.cmd == CLAIM_DESTINATION: serial.write_line(\"radio tx claim destinatination\")\n                if robot.cmd == RELEASE_ROUTE: serial.write_line(\"radio tx release route\")\n            RadioTxPending = True\n        #if RadioTxPending and not WaitingForReply:\n            radio_transmit(robot) # send message\n            RadioTxPending =  False # we have send the message\n            RadioTxTime = input.running_time() # note send time\n            WaitingForReply = True # start waiting for reply\n        elif WaitingForReply and (input.running_time() - RadioTxTime) > 1000: # timeout after 1 second\n            RadioTxPending = True # retry\n            WaitingForReply = False\n            RadioTxTime = input.running_time()\n            \n        if HIL_Simulation: \n            basic.pause(50)\n            newdata = True\n        if newdata:\n            newdata = False # sync to Huskylens\n            do_robot(robot)\n            print_data()\n\n    if HIL_Simulation: basic.pause(50)\n    #print_data() -> background loop\n    if stopping:\n        robot.active = False\n        robot.location = 1\n        robot.destination = 1\n        robot.target = 1\n        robot.objecttype = None\n        robot.state = IDLE\n    pass\n    yield_(5) # yield for other processes\n\nbasic.forever(on_forever)\n\n\n\ndef on_in_background():\n    #Huskylens\n    global t_start, t_last, dt_AI, inview, tagsInView, inview_count, x, y, w, h, newdata, zeroes\n    # approx 56 ms -> ~ 18 fps\n    t_start = input.running_time()\n    t_last = t_start\n    while 1:\n        \n        t_start = input.running_time()\n        dt_AI = t_start - t_last\n        # loop time\n        t_last = t_start\n        huskylens.request()\n        #yield_(20) # yield for other processes\n        inview = huskylens.get_box(HUSKYLENSResultType_t.HUSKYLENS_RESULT_BLOCK)\n        tagsInView = zeroes\n        k = 0\n        while k < inview:\n            tagsInView[k] = huskylens.readBox_ss(k + 1, Content3.ID)\n            k += 1\n        #serial.write_line(\"gripper : \"+str(robot.gripper))\n        if huskylens.is_appear(robot.target, HUSKYLENSResultType_t.HUSKYLENS_RESULT_BLOCK):\n            x = huskylens.reade_box(robot.target, Content1.X_CENTER)\n            y = huskylens.reade_box(robot.target, Content1.Y_CENTER)\n            w = huskylens.reade_box(robot.target, Content1.WIDTH)\n            h = huskylens.reade_box(robot.target, Content1.HEIGHT)\n            inview_count = 0\n        else:\n            inview_count += 1\n            if inview_count > 5: # if 3 frames no valid tag, reset to 0\n                x = -1\n                y = -1\n                w = -1\n                h = -1\n        newdata = True\n\n                          \ncontrol.in_background(on_in_background)","pxt.json":"{\n    \"name\": \"MPPS_demonstrator_python_only_v06\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"Huskylens\": \"github:dfrobot/pxt-dfrobot_huskylens#v2.0.6\",\n        \"maqueen\": \"github:dfrobot/pxt-maqueen#v1.7.5\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"7.0.51\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}}],"shares":[],"lastSaveTime":1735233964426}